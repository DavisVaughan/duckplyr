[{"path":"https://duckdblabs.github.io/duckplyr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 duckplyr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hannes Mühleisen. Author. Kirill Müller. Author, maintainer. Posit Software, PBC. Copyright holder, funder.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mühleisen H, Müller K (2023). duckplyr: 'DuckDB'-Backed Version 'dplyr'. https://duckdblabs.github.io/duckplyr/, https://github.com/duckdblabs/duckplyr.","code":"@Manual{,   title = {duckplyr: A 'DuckDB'-Backed Version of 'dplyr'},   author = {Hannes Mühleisen and Kirill Müller},   year = {2023},   note = {https://duckdblabs.github.io/duckplyr/, https://github.com/duckdblabs/duckplyr}, }"},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"duckplyr","dir":"","previous_headings":"","what":"A DuckDB-Backed Version of dplyr","title":"A DuckDB-Backed Version of dplyr","text":"goal duckplyr provide drop-replacement dplyr uses DuckDB backend fast operation. also defines set generics provide low-level implementer’s interface dplyr’s high-level user interface.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"A DuckDB-Backed Version of dplyr","text":"two ways use duckplyr. enable individual data frames, use as_duckplyr_df() first step pipe. enable entire session, use methods_overwrite(). examples illustrate methods. See also companion demo repository use case large dataset.","code":"library(conflicted) library(duckplyr) conflict_prefer(\"filter\", \"duckplyr\") #> [conflicted] Will prefer duckplyr::filter over #> any other package."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"individual","dir":"","previous_headings":"Example","what":"Individual","title":"A DuckDB-Backed Version of dplyr","text":"example illustrates usage duckplyr individual data frames.","code":"# Use `as_duckplyr_df()` to enable processing with duckdb: out <-   palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   as_duckplyr_df() %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\")  # The result is a data frame or tibble, with its own class. class(out) #> [1] \"duckplyr_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" names(out) #> [1] \"species\"        \"sex\"            \"mean_bill_area\"  # duckdb is responsible for eventually carrying out the operations. # Despite the late filter, the summary is not computed for the Gentoo species. out %>%   explain() #> ┌───────────────────────────┐ #> │       HASH_GROUP_BY       │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │             #0            │ #> │             #1            │ #> │          mean(#2)         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │         PROJECTION        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │            sex            │ #> │         bill_area         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │         PROJECTION        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │            sex            │ #> │         bill_area         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │           FILTER          │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │   (species != 'Gentoo')   │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │           EC: 0           │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │     R_DATAFRAME_SCAN      │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │         data.frame        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │       bill_length_mm      │ #> │       bill_depth_mm       │ #> │            sex            │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │           EC: 0           │ #> └───────────────────────────┘  # All data frame operations are supported. # Computation happens upon the first request. out$mean_bill_area #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Filter [!=(species, 'Gentoo')] #>   Aggregate [species, sex, mean(bill_area)] #>     Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, *(bill_length_mm, bill_depth_mm) as bill_area] #>       r_dataframe_scan(0x107a45b78) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - species (VARCHAR) #> - sex (VARCHAR) #> - mean_bill_area (DOUBLE) #>  #> [1] 770.2627 656.8523 694.9360 819.7503 984.2279  # After the computation has been carried out, the results are available # immediately: out #> # A tibble: 5 × 3 #>   species   sex    mean_bill_area #>   <chr>     <chr>           <dbl> #> 1 Adelie    male             770. #> 2 Adelie    female           657. #> 3 Adelie    NA               695. #> 4 Chinstrap female           820. #> 5 Chinstrap male             984."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"session-wide","dir":"","previous_headings":"Example","what":"Session-wide","title":"A DuckDB-Backed Version of dplyr","text":"example illustrates usage duckplyr data frames R session.","code":"# Use `methods_overwrite()` to enable processing with duckdb for all data frames: methods_overwrite()  # This is the same query as above, without `as_duckplyr_df()`: out <-   palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\")  # The result is a plain tibble now: class(out) #> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"  # Querying the number of rows also starts the computation: nrow(out) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Filter [!=(species, 'Gentoo')] #>   Aggregate [species, sex, mean(bill_area)] #>     Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, *(bill_length_mm, bill_depth_mm) as bill_area] #>       r_dataframe_scan(0x1254b4b58) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - species (VARCHAR) #> - sex (VARCHAR) #> - mean_bill_area (DOUBLE) #> [1] 5  # Restart R, or call `methods_restore()` to revert to the default dplyr implementation. methods_restore()  # dplyr is active again: palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\") #> # A tibble: 5 × 3 #>   species   sex    mean_bill_area #>   <chr>     <chr>           <dbl> #> 1 Adelie    male             770. #> 2 Adelie    female           657. #> 3 Adelie    NA                NA  #> 4 Chinstrap female           820. #> 5 Chinstrap male             984."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"extensibility","dir":"","previous_headings":"","what":"Extensibility","title":"A DuckDB-Backed Version of dplyr","text":"package also provides generics, packages may implement methods.","code":"library(duckplyr)  new_dfrel <- function(x) {   stopifnot(is.data.frame(x))   new_relational(list(x), class = \"dfrel\") } mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])  rel_to_df.dfrel <- function(rel, ...) {   unclass(rel)[[1]] } rel_to_df(mtcars_rel) #>                    mpg cyl disp  hp #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Datsun 710        22.8   4  108  93 #> Hornet 4 Drive    21.4   6  258 110 #> Hornet Sportabout 18.7   8  360 175  rel_filter.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the predicates defined   # by the exprs argument   new_dfrel(df[sample.int(nrow(df), 3, replace = TRUE), ]) }  rel_filter(   mtcars_rel,   list(     relexpr_function(       \"gt\",       list(relexpr_reference(\"cyl\"), relexpr_constant(\"6\"))     )   ) ) #> [[1]] #>                  mpg cyl disp  hp #> Mazda RX4 Wag   21.0   6  160 110 #> Mazda RX4 Wag.1 21.0   6  160 110 #> Datsun 710      22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_project.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, ncol(df)))]) }  rel_project(   mtcars_rel,   list(relexpr_reference(\"cyl\"), relexpr_reference(\"disp\")) ) #> [[1]] #>                    mpg cyl disp #> Mazda RX4         21.0   6  160 #> Mazda RX4 Wag     21.0   6  160 #> Datsun 710        22.8   4  108 #> Hornet 4 Drive    21.4   6  258 #> Hornet Sportabout 18.7   8  360 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_order.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[order(df[[1]]), ]) }  rel_order(   mtcars_rel,   list(relexpr_reference(\"mpg\")) ) #> [[1]] #>                    mpg cyl disp  hp #> Hornet Sportabout 18.7   8  360 175 #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Hornet 4 Drive    21.4   6  258 110 #> Datsun 710        22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\" rel_join.dfrel <- function(left, right, conds, join, ...) {   left_df <- unclass(left)[[1]]   right_df <- unclass(right)[[1]]    # A real implementation would evaluate the expressions   # defined by the conds argument,   # use different join types based on the join argument,   # and implement the join itself instead of relaying to left_join().   new_dfrel(dplyr::left_join(left_df, right_df)) }  rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel) #> Joining with `by = join_by(mpg)` #> [[1]] #>   mpg cyl disp  hp #> 1  21   6  160 110 #> 2  21   6  160 110 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_limit.dfrel <- function(rel, n, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[seq_len(n), ]) }  rel_limit(mtcars_rel, 3) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_distinct.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[!duplicated(df), ]) }  rel_distinct(new_dfrel(mtcars[1:3, 1:4])) #> [[1]] #>             mpg cyl disp  hp #> Mazda RX4  21.0   6  160 110 #> Datsun 710 22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_names.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    names(df) }  rel_names(mtcars_rel) #> [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\""},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A DuckDB-Backed Version of dplyr","text":"Install duckplyr CRAN : can also install development version duckplyr GitHub :","code":"install.packages(\"duckplyr\") # install.packages(\"pak\", repos = sprintf(\"https://r-lib.github.io/p/pak/stable/%s/%s/%s\", .Platform$pkgType, R.Version()$os, R.Version()$arch)) pak::pak(\"duckdblabs/duckplyr\")"},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to a duckplyr data frame — as_duckplyr_df","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"object class duckplyr_df, dplyr verbs mutate(), select() filter()  attempt use DuckDB. possible, original dplyr implementation used.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"","code":"as_duckplyr_df(.data)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":".data data frame tibble transform","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"object class \"duckplyr_df\", inheriting classes .data argument.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"Set DUCKPLYR_FALLBACK_INFO DUCKPLYR_FORCE environment variables control behavior, see config details.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"","code":"tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x55dba868d778) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4"},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":null,"dir":"Reference","previous_headings":"","what":"Configuration options — config","title":"Configuration options — config","text":"behavior duckplyr can fine-tuned several environment variables, one option.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"options","dir":"Reference","previous_headings":"","what":"Options","title":"Configuration options — config","text":"duckdb.materialize_message: Set FALSE turn diagnostic output duckdb data frame materialization. Currenty set TRUE duckplyr loaded.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"environment-variables","dir":"Reference","previous_headings":"","what":"Environment variables","title":"Configuration options — config","text":"DUCKPLYR_OUTPUT_ORDER: TRUE, row output order preserved. default may change row order dplyr keep stable. DUCKPLYR_FORCE: TRUE, fail duckdb handle request. DUCKPLYR_FALLBACK_INFO: TRUE, print message fallback dplyr occurs duckdb handle request. DUCKPLYR_CHECK_ROUNDTRIP: TRUE, check columns roundtripped perfectly creating relational object data frame, slow, mostly useful debugging. default check roundtrip attributes. DUCKPLYR_EXPERIMENTAL: TRUE, pass experimental = TRUE certain duckdb functions. Currently unused.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Configuration options — config","text":"","code":"# options(duckdb.materialize_message = FALSE) data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   inner_join(data.frame(a = 1:4), by = \"a\") #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Join INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>     Projection [a as a_x] #>       r_dataframe_scan(0x55dba3d922d8) #>     Projection [a as a_y] #>       r_dataframe_scan(0x55dba3d19358) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 1 #> 2 2 #> 3 3  rlang::with_options(duckdb.materialize_message = FALSE, {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     inner_join(data.frame(a = 1:4), by = \"a\") %>%     print() }) #>   a #> 1 1 #> 2 2 #> 3 3  # Sys.setenv(DUCKPLYR_OUTPUT_ORDER = TRUE) data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   inner_join(data.frame(a = 1:4), by = \"a\") #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Join INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>     Projection [a as a_x] #>       r_dataframe_scan(0x55dba0fc5e50) #>     Projection [a as a_y] #>       r_dataframe_scan(0x55dba0ddac20) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 1 #> 2 2 #> 3 3  withr::with_envvar(c(DUCKPLYR_OUTPUT_ORDER = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     inner_join(data.frame(a = 1:4), by = \"a\") }) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Order [lhs.___row_number_x ASC, rhs.___row_number_y ASC] #>     Join INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>       Projection [a_x as a_x, row_number() OVER () as ___row_number_x] #>         Projection [a as a_x] #>           r_dataframe_scan(0x55dba5c9f640) #>       Projection [a_y as a_y, row_number() OVER () as ___row_number_y] #>         Projection [a as a_y] #>           r_dataframe_scan(0x55dba5c9e6b8) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 3 #> 2 2 #> 3 1  # Sys.setenv(DUCKPLYR_FORCE = TRUE) add_one <- function(x) {   x + 1 }  data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   mutate(b = add_one(a)) #>   a b #> 1 3 4 #> 2 2 3 #> 3 1 2  try(withr::with_envvar(c(DUCKPLYR_FORCE = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     mutate(b = add_one(a)) })) #> Error in do_translate(expr) : Unknown function: add_one  # Sys.setenv(DUCKPLYR_FALLBACK_INFO = TRUE) withr::with_envvar(c(DUCKPLYR_FALLBACK_INFO = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     mutate(b = add_one(a)) }) #> Error processing with relational. #> Caused by error in `do_translate()` at duckplyr/R/relational.R:227:2: #> ! Unknown function: add_one #>   a b #> 1 3 4 #> 2 2 3 #> 3 1 2"},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Read Parquet, CSV, and other files using DuckDB — df_from_file","title":"Read Parquet, CSV, and other files using DuckDB — df_from_file","text":"function ingests data files. Internally, DuckDB table-valued function called, results transparently converted data frame. data read data actually accessed. See https://duckdb.org/docs/data/overview documentation available functions options. duckplyr_df_from_file() thin wrapper around df_from_file() calls as_duckplyr_df() output.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read Parquet, CSV, and other files using DuckDB — df_from_file","text":"","code":"df_from_file(path, table_function, options = list(), class = NULL)  duckplyr_df_from_file(path, table_function, options = list(), class = NULL)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read Parquet, CSV, and other files using DuckDB — df_from_file","text":"path Path file directory table_function name table-valued DuckDB function \"read_parquet\", \"read_csv\", \"read_csv_auto\" \"read_json\". options Arguments DuckDB function indicated table_function. class optional class add data frame. returned object always data frame. Pass class(tibble()) create tibble.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read Parquet, CSV, and other files using DuckDB — df_from_file","text":"data frame df_from_file(), duckplyr_df duckplyr_df_from_file(), extended provided class.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read Parquet, CSV, and other files using DuckDB — df_from_file","text":"","code":"# Create simple CSV file path <- tempfile(fileext = \".csv\") write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)  # Reading is immediate df <- df_from_file(path, \"read_csv_auto\")  # Materialization only upon access names(df) #> [1] \"a\" \"b\" df$a #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_csv_auto(/tmp/RtmpPM9Hl1/file10475b2e2f6a.csv) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (BIGINT) #> - b (VARCHAR) #>  #> [1] 1 2 3  # Return as tibble: df_from_file(   path,   \"read_csv\",   options = list(delim = \",\", auto_detect = TRUE),   class = class(tibble()) ) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_csv(/tmp/RtmpPM9Hl1/file10475b2e2f6a.csv) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (BIGINT) #> - b (VARCHAR) #>  #> # A tibble: 3 × 2 #>       a b     #>   <dbl> <chr> #> 1     1 d     #> 2     2 e     #> 3     3 f      unlink(path)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/duckplyr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","title":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","text":"drop-replacement 'dplyr', powered 'DuckDB' performance. Also defines set generics provide low-level implementer's interface high-level user interface 'dplyr'.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/reference/duckplyr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","text":"Maintainer: Kirill Müller kirill@cynkra.com (ORCID) Authors: Hannes Mühleisen (ORCID) contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Class predicate for duckplyr data frames — is_duckplyr_df","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"Tests input object class \"duckplyr_df\".","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"","code":"is_duckplyr_df(.data)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":".data object test","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"TRUE input object class \"duckplyr_df\", otherwise FALSE.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"","code":"tibble(a = 1:3) %>%   is_duckplyr_df() #> [1] FALSE  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   is_duckplyr_df() #> [1] TRUE"},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":null,"dir":"Reference","previous_headings":"","what":"Forward all dplyr methods to duckplyr — methods_overwrite","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"calling methods_overwrite(), dplyr methods redirected duckplyr duraton session, call methods_restore().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"","code":"methods_overwrite()  methods_restore()"},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"Called side effects.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"","code":"tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  methods_overwrite()  tibble(a = 1:3) %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x55dbaa9c4068) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  methods_restore()  tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational implementer's interface — new_relational","title":"Relational implementer's interface — new_relational","text":"constructor generics described define class helps separating dplyr's user interface actual underlying operations. longer term, help packages implement dplyr interface (dbplyr, dtplyr, arrow similar) focus core details functionality, rather intricacies dplyr's user interface. new_relational() constructs object class \"relational\". Users encouraged provide class argument. typical use case create wrapper function. rel_to_df() extracts data frame representation relational object, used dplyr::collect(). rel_filter() keeps rows match predicate, used dplyr::filter(). rel_project() selects columns creates new columns, used dplyr::select(), dplyr::rename(), dplyr::mutate(), dplyr::relocate(), others. rel_aggregate() combines several rows one, used dplyr::summarize(). rel_order() reorders rows columns expressions, used dplyr::arrange(). rel_join() joins merges two tables, used dplyr::left_join(), dplyr::right_join(), dplyr::inner_join(), dplyr::full_join(), dplyr::cross_join(), dplyr::semi_join(), dplyr::anti_join(). rel_limit() limits number rows table, used utils::head(). rel_distinct() keeps distinct rows table, used dplyr::distinct(). rel_set_intersect() returns rows present tables, used intersect(). rel_set_diff() returns rows present tables, used setdiff(). rel_set_symdiff() returns rows present tables, used dplyr::symdiff(). rel_union_all() returns rows present tables, used dplyr::union_all(). rel_explain() prints explanation plan executed relational object. rel_alias() returns alias name relational object. rel_set_alias() sets alias name relational object. rel_names() returns column names character vector, used colnames().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational implementer's interface — new_relational","text":"","code":"new_relational(..., class = NULL)  rel_to_df(rel, ...)  rel_filter(rel, exprs, ...)  rel_project(rel, exprs, ...)  rel_aggregate(rel, groups, aggregates, ...)  rel_order(rel, orders, ...)  rel_join(   left,   right,   conds,   join = c(\"inner\", \"left\", \"right\", \"outer\", \"cross\", \"semi\", \"anti\"),   join_ref_type = c(\"regular\", \"natural\", \"cross\", \"positional\", \"asof\"),   ... )  rel_limit(rel, n, ...)  rel_distinct(rel, ...)  rel_set_intersect(rel_a, rel_b, ...)  rel_set_diff(rel_a, rel_b, ...)  rel_set_symdiff(rel_a, rel_b, ...)  rel_union_all(rel_a, rel_b, ...)  rel_explain(rel, ...)  rel_alias(rel, ...)  rel_set_alias(rel, alias, ...)  rel_names(rel, ...)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational implementer's interface — new_relational","text":"... Reserved future extensions, must empty. class Classes added front \"relational\" base class. rel, rel_a, rel_b, left, right relational object. exprs list expr objects filter . groups list expressions group . aggregates list expressions aggregates compute. orders list expressions order . conds list expressions use join. join type join. join_ref_type ref type join. n number rows. alias new alias","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational implementer's interface — new_relational","text":"new_relational() returns new relational object. rel_to_df() returns data frame. rel_names() returns character vector. generics return modified relational object.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational implementer's interface — new_relational","text":"","code":"new_dfrel <- function(x) {   stopifnot(is.data.frame(x))   new_relational(list(x), class = \"dfrel\") } mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])  rel_to_df.dfrel <- function(rel, ...) {   unclass(rel)[[1]] } rel_to_df(mtcars_rel) #>                    mpg cyl disp  hp #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Datsun 710        22.8   4  108  93 #> Hornet 4 Drive    21.4   6  258 110 #> Hornet Sportabout 18.7   8  360 175  rel_filter.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the predicates defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, nrow(df))), ]) }  rel_filter(   mtcars_rel,   list(     relexpr_function(       \"gt\",       list(relexpr_reference(\"cyl\"), relexpr_constant(\"6\"))     )   ) ) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_project.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, ncol(df)))]) }  rel_project(   mtcars_rel,   list(relexpr_reference(\"cyl\"), relexpr_reference(\"disp\")) ) #> [[1]] #>                    mpg cyl disp #> Mazda RX4         21.0   6  160 #> Mazda RX4 Wag     21.0   6  160 #> Datsun 710        22.8   4  108 #> Hornet 4 Drive    21.4   6  258 #> Hornet Sportabout 18.7   8  360 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_order.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[order(df[[1]]), ]) }  rel_order(   mtcars_rel,   list(relexpr_reference(\"mpg\")) ) #> [[1]] #>                    mpg cyl disp  hp #> Hornet Sportabout 18.7   8  360 175 #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Hornet 4 Drive    21.4   6  258 110 #> Datsun 710        22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\" rel_join.dfrel <- function(left, right, conds, join, ...) {   left_df <- unclass(left)[[1]]   right_df <- unclass(right)[[1]]    # A real implementation would evaluate the expressions   # defined by the conds argument,   # use different join types based on the join argument,   # and implement the join itself instead of relaying to left_join().   new_dfrel(dplyr::left_join(left_df, right_df)) }  rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel) #> Joining with `by = join_by(mpg)` #> [[1]] #>   mpg cyl disp  hp #> 1  21   6  160 110 #> 2  21   6  160 110 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_limit.dfrel <- function(rel, n, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[seq_len(n), ]) }  rel_limit(mtcars_rel, 3) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_distinct.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[!duplicated(df), ]) }  rel_distinct(new_dfrel(mtcars[1:3, 1:4])) #> [[1]] #>             mpg cyl disp  hp #> Mazda RX4  21.0   6  160 110 #> Datsun 710 22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_names.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    names(df) }  rel_names(mtcars_rel) #> [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational expressions — new_relexpr","title":"Relational expressions — new_relexpr","text":"functions provide backend-agnostic way construct expression trees built column references, constants, functions. subexpressions expression tree can alias. new_relexpr() constructs object class \"relational_relexpr\". used higher-level constructors, users rarely need call directly. relexpr_reference() constructs reference column. relexpr_constant() wraps constant value. relexpr_function() applies function. arguments function list expression objects. relexpr_window() applies function window, similarly SQL clause. relexpr_set_alias() assigns alias expression.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational expressions — new_relexpr","text":"","code":"new_relexpr(x, class = NULL)  relexpr_reference(name, rel = NULL, alias = NULL)  relexpr_constant(val, alias = NULL)  relexpr_function(name, args, alias = NULL)  relexpr_window(   expr,   partitions,   order_bys = list(),   offset_expr = NULL,   default_expr = NULL,   alias = NULL )  relexpr_set_alias(expr, alias = NULL)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational expressions — new_relexpr","text":"x object. class Classes added front \"relational_relexpr\" base class. name name column function reference. rel name relation reference. alias alias new expression. val value use constant expression. args Function arguments, list expr objects. expr expr object. partitions Partitions, list expr objects. order_bys variables order results (list). offset_expr offset relational expression. default_expr default relational expression.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational expressions — new_relexpr","text":"object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\"","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational expressions — new_relexpr","text":"","code":"relexpr_set_alias(   alias = \"my_predicate\",   relexpr_function(     \"<\",     list(       relexpr_reference(\"my_number\"),       relexpr_constant(42)     )   ) ) #> List of 3 #>  $ name : chr \"<\" #>  $ args :List of 2 #>   ..$ :List of 3 #>   .. ..$ name : chr \"my_number\" #>   .. ..$ rel  : NULL #>   .. ..$ alias: NULL #>   .. ..- attr(*, \"class\")= chr [1:2] \"relational_relexpr_reference\" \"relational_relexpr\" #>   ..$ :List of 2 #>   .. ..$ val  : num 42 #>   .. ..$ alias: NULL #>   .. ..- attr(*, \"class\")= chr [1:2] \"relational_relexpr_constant\" \"relational_relexpr\" #>  $ alias: chr \"my_predicate\" #>  - attr(*, \"class\")= chr [1:2] \"relational_relexpr_function\" \"relational_relexpr\""},{"path":"https://duckdblabs.github.io/duckplyr/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. dplyr %>%, across, add_count, add_tally, all_equal, anti_join, arrange, auto_copy, c_across, case_when, collapse, collect, compute, count, cross_join, desc, distinct, , dplyr_col_modify, dplyr_reconstruct, dplyr_row_slice, explain, filter, first, full_join, funs, funs_, group_by, group_data, group_keys, group_map, group_modify, group_rows, group_size, group_vars, group_walk, if_all, if_any, inner_join, intersect, is_grouped_df, join_by, lag, last, lead, left_join, mutate, mutate_all, n, n_distinct, nest_by, nest_join, nth, pull, reframe, relocate, rename, rename_all, rename_at, rename_if, rename_with, right_join, row_number, rows_append, rows_delete, rows_insert, rows_patch, rows_update, rows_upsert, rowwise, same_src, sample_frac, sample_n, select, select_all, select_at, select_if, semi_join, setdiff, setequal, slice, slice_head, slice_max, slice_min, slice_sample, slice_tail, summarise, summarise_all, summarise_at, summarize, symdiff, tally, tbl_vars, tibble, transmute, ungroup, union, union_all, vars, with_groups","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":null,"dir":"Reference","previous_headings":"","what":"Show stats — stats_show","title":"Show stats — stats_show","text":"Prints statistics many calls handled DuckDB. output shows total number requests current session, split fallbacks dplyr requests handled duckdb.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show stats — stats_show","text":"","code":"stats_show()"},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show stats — stats_show","text":"Called side effect.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show stats — stats_show","text":"","code":"stats_show() #> 🛠: 9 #> 🔨: 2 #> 🦆: 7 #> inner_join, mutate, mutate.data.frame  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x55dbaa9c87b8) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  stats_show() #> 🛠: 10 #> 🔨:  2 #> 🦆:  8 #> inner_join, mutate, mutate.data.frame"},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-021-2023-09-16","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.1 (2023-09-16)","title":"duckplyr 0.2.1 (2023-09-16)","text":"CRAN release: 2023-09-17 Improve documentation. Work around problem dplyr_reconstruct() R 4.3. Rename duckdb_from_file() df_from_file(). Unexport private duckdb_rel_from_df(), rel_from_df(), wrap_df() wrap_integer(). Reexport %>% tibble().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-020-2023-09-10","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.0 (2023-09-10)","title":"duckplyr 0.2.0 (2023-09-10)","text":"CRAN release: 2023-09-10 Implement relational API DuckDB.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-010-2023-07-03","dir":"Changelog","previous_headings":"","what":"duckplyr 0.1.0 (2023-07-03)","title":"duckplyr 0.1.0 (2023-07-03)","text":"CRAN release: 2023-07-07","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-1-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.1.0 (2023-07-03)","text":"Fix examples.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-1-0","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.1.0 (2023-07-03)","text":"Add CRAN install instructions. Satisfy R CMD check. Document argument. Error NOTE. Remove relexpr_window() now.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-1-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.1.0 (2023-07-03)","text":"Clean reference.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"uncategorized-0-1-0","dir":"Changelog","previous_headings":"","what":"Uncategorized","title":"duckplyr 0.1.0 (2023-07-03)","text":"Initial version, exporting: - new_relational() construct objects class \"relational\" - Generics rel_aggregate(), rel_distinct(), rel_filter(), rel_join(), rel_limit(), rel_names(), rel_order(), rel_project(), rel_set_diff(), rel_set_intersect(), rel_set_symdiff(), rel_to_df(), rel_union_all() - new_relexpr() construct objects class \"relational_relexpr\" - Expression builders relexpr_constant(), relexpr_function(), relexpr_reference(), relexpr_set_alias(), relexpr_window()","code":""}]
