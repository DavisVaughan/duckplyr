[{"path":"https://duckdblabs.github.io/duckplyr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 duckplyr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hannes Mühleisen. Author. Kirill Müller. Author, maintainer. Posit Software, PBC. Copyright holder, funder.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mühleisen H, Müller K (2024). duckplyr: 'DuckDB'-Backed Version 'dplyr'. R package version 0.3.2.9009, https://github.com/duckdblabs/duckplyr, https://duckdblabs.github.io/duckplyr/.","code":"@Manual{,   title = {duckplyr: A 'DuckDB'-Backed Version of 'dplyr'},   author = {Hannes Mühleisen and Kirill Müller},   year = {2024},   note = {R package version 0.3.2.9009, https://github.com/duckdblabs/duckplyr},   url = {https://duckdblabs.github.io/duckplyr/}, }"},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"duckplyr","dir":"","previous_headings":"","what":"A DuckDB-Backed Version of dplyr","title":"A DuckDB-Backed Version of dplyr","text":"goal duckplyr provide drop-replacement dplyr uses DuckDB backend fast operation. DuckDB -process SQL OLAP database management system. duckplyr also defines set generics provide low-level implementer’s interface dplyr’s high-level user interface.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A DuckDB-Backed Version of dplyr","text":"Install duckplyr CRAN : can also install development version duckplyr R-universe: GitHub :","code":"install.packages(\"duckplyr\") install.packages('duckplyr', repos = c('https://duckdblabs.r-universe.dev', 'https://cloud.r-project.org')) # install.packages(\"pak\", repos = sprintf(\"https://r-lib.github.io/p/pak/stable/%s/%s/%s\", .Platform$pkgType, R.Version()$os, R.Version()$arch)) pak::pak(\"duckdblabs/duckplyr\")"},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"A DuckDB-Backed Version of dplyr","text":"two ways use duckplyr. enable duckplyr individual data frames, use as_duckplyr_df() first step pipe. enable duckplyr entire session, use methods_overwrite(). examples illustrate methods. See also companion demo repository use case large dataset.","code":"library(conflicted) library(duckplyr) conflict_prefer(\"filter\", \"duckplyr\") #> [conflicted] Will prefer duckplyr::filter over #> any other package."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"usage-for-individual-data-frames","dir":"","previous_headings":"Examples","what":"Usage for individual data frames","title":"A DuckDB-Backed Version of dplyr","text":"example illustrates usage duckplyr individual data frames. Use as_duckplyr_df() enable processing duckdb: result data frame tibble, class. duckdb responsible eventually carrying operations. Despite late filter, summary computed Gentoo species. data frame operations supported. Computation happens upon first request. computation carried , results available immediately:","code":"out <-   palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   as_duckplyr_df() %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\") class(out) #> [1] \"duckplyr_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" names(out) #> [1] \"species\"        \"sex\"            \"mean_bill_area\" out %>%   explain() #> ┌───────────────────────────┐ #> │          ORDER_BY         │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          ORDERS:          │ #> │      dataframe_42_42      │ #> │      42.___row_number ASC     │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │           FILTER          │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │   (species != 'Gentoo')   │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          EC: 344          │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │      STREAMING_WINDOW     │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │    ROW_NUMBER() OVER ()   │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │          ORDER_BY         │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          ORDERS:          │ #> │      dataframe_42_42      │ #> │      42.___row_number ASC     │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │       HASH_GROUP_BY       │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │             #0            │ #> │             #1            │ #> │          min(#2)          │ #> │          mean(#3)         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │         PROJECTION        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │            sex            │ #> │       ___row_number       │ #> │         bill_area         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │      STREAMING_WINDOW     │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │    ROW_NUMBER() OVER ()   │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │         PROJECTION        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │            sex            │ #> │         bill_area         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │     R_DATAFRAME_SCAN      │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │         data.frame        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │       bill_length_mm      │ #> │       bill_depth_mm       │ #> │            sex            │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          EC: 344          │ #> └───────────────────────────┘ out$mean_bill_area #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [species as species, sex as sex, mean_bill_area as mean_bill_area] #>   Order [___row_number ASC] #>     Filter [!=(species, 'Gentoo')] #>       Projection [species as species, sex as sex, mean_bill_area as mean_bill_area, row_number() OVER () as ___row_number] #>         Projection [species as species, sex as sex, mean_bill_area as mean_bill_area] #>           Order [___row_number ASC] #>             Aggregate [species, sex, min(___row_number), mean(bill_area)] #>               Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, bill_area as bill_area, row_number() OVER () as ___row_number] #>                 Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, *(bill_length_mm, bill_depth_mm) as bill_area] #>                   r_dataframe_scan(0xdeadbeef) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - species (VARCHAR) #> - sex (VARCHAR) #> - mean_bill_area (DOUBLE) #>  #> [1] 770.2627 656.8523 694.9360 819.7503 984.2279 out #> # A tibble: 5 × 3 #>   species   sex    mean_bill_area #>   <chr>     <chr>           <dbl> #> 1 Adelie    male             770. #> 2 Adelie    female           657. #> 3 Adelie    NA               695. #> 4 Chinstrap female           820. #> 5 Chinstrap male             984."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"session-wide-usage","dir":"","previous_headings":"Examples","what":"Session-wide usage","title":"A DuckDB-Backed Version of dplyr","text":"example illustrates usage duckplyr data frames R session. Use methods_overwrite() enable processing duckdb data frames: query , without as_duckplyr_df(): result plain tibble now: Querying number rows also starts computation: Restart R, call methods_restore() revert default dplyr implementation. dplyr active :","code":"methods_overwrite() #> ℹ Overwriting dplyr methods with duckplyr #> methods out <-   palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\") class(out) #> [1] \"tbl_df\"     \"tbl\"        \"data.frame\" nrow(out) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [species as species, sex as sex, mean_bill_area as mean_bill_area] #>   Order [___row_number ASC] #>     Filter [!=(species, 'Gentoo')] #>       Projection [species as species, sex as sex, mean_bill_area as mean_bill_area, row_number() OVER () as ___row_number] #>         Projection [species as species, sex as sex, mean_bill_area as mean_bill_area] #>           Order [___row_number ASC] #>             Aggregate [species, sex, min(___row_number), mean(bill_area)] #>               Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, bill_area as bill_area, row_number() OVER () as ___row_number] #>                 Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, *(bill_length_mm, bill_depth_mm) as bill_area] #>                   r_dataframe_scan(0xdeadbeef) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - species (VARCHAR) #> - sex (VARCHAR) #> - mean_bill_area (DOUBLE) #> [1] 5 methods_restore() #> ℹ Restoring dplyr methods palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\") #> # A tibble: 5 × 3 #>   species   sex    mean_bill_area #>   <chr>     <chr>           <dbl> #> 1 Adelie    male             770. #> 2 Adelie    female           657. #> 3 Adelie    NA                NA  #> 4 Chinstrap female           820. #> 5 Chinstrap male             984."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"telemetry","dir":"","previous_headings":"","what":"Telemetry","title":"A DuckDB-Backed Version of dplyr","text":"like guide efforts towards improving duckplyr, focusing features impact. end, duckplyr collects uploads telemetry data, permitted user. data collected contains: package version error message input data frames, structure included (column types ), column names data first time package encounters unsupported function, data type, operation, instructions printed console.","code":"palmerpenguins::penguins %>%   as_duckplyr_df() %>%   transmute(bill_area = bill_length_mm * bill_depth_mm) %>%   head(3) #> The duckplyr package is configured to fall back to dplyr when it encounters an #> incompatibility. Fallback events can be collected and uploaded for analysis to #> guide future development. By default, no data will be collected or uploaded. #> ℹ A fallback situation just occurred. The following information would have been #>   recorded: #>   {\"version\":\"0.3.1\",\"message\":\"Can't convert columns of class <factor> to #>   relational. Affected #>   column:\\n`...1`.\",\"name\":\"transmute\",\"x\":{\"...1\":\"factor\",\"...2\":\"factor\",\"...3\":\"numeric\",\"...4\":\"numeric\",\"...5\":\"integer\",\"...6\":\"integer\",\"...7\":\"factor\",\"...8\":\"integer\"},\"args\":{\"dots\":{\"...9\":\"...3 #>   * ...4\"}}} #> → Run `duckplyr::fallback_sitrep()` to review the current settings. #> → Run `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 1)` to enable fallback logging, #>   and `Sys.setenv(DUCKPLYR_FALLBACK_VERBOSE = 1)` in addition to enable #>   printing of fallback situations to the console. #> → Run `duckplyr::fallback_review()` to review the available reports, and #>   `duckplyr::fallback_upload()` to upload them. #> ℹ See `?duckplyr::fallback()` for details. #> ℹ This message will be displayed once every eight hours. #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Limit 3 #>   r_dataframe_scan(0xdeadbeef) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - bill_area (DOUBLE) #>  #> # A tibble: 3 × 1 #>   bill_area #>       <dbl> #> 1      731. #> 2      687. #> 3      725."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"extensibility","dir":"","previous_headings":"","what":"Extensibility","title":"A DuckDB-Backed Version of dplyr","text":"package also provides generics, packages may implement methods.","code":"library(duckplyr)  # Create a relational to be used by examples below new_dfrel <- function(x) {   stopifnot(is.data.frame(x))   new_relational(list(x), class = \"dfrel\") } mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])  # Example 1: return a data.frame rel_to_df.dfrel <- function(rel, ...) {   unclass(rel)[[1]] } rel_to_df(mtcars_rel) #>                    mpg cyl disp  hp #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Datsun 710        22.8   4  108  93 #> Hornet 4 Drive    21.4   6  258 110 #> Hornet Sportabout 18.7   8  360 175  # Example 2: A (random) filter rel_filter.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the predicates defined   # by the exprs argument   new_dfrel(df[sample.int(nrow(df), 3, replace = TRUE), ]) }  rel_filter(   mtcars_rel,   list(     relexpr_function(       \"gt\",       list(relexpr_reference(\"cyl\"), relexpr_constant(\"6\"))     )   ) ) #> [[1]] #>                  mpg cyl disp  hp #> Mazda RX4 Wag   21.0   6  160 110 #> Mazda RX4 Wag.1 21.0   6  160 110 #> Datsun 710      22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 3: A custom projection rel_project.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, ncol(df)))]) }  rel_project(   mtcars_rel,   list(relexpr_reference(\"cyl\"), relexpr_reference(\"disp\")) ) #> [[1]] #>                    mpg cyl disp #> Mazda RX4         21.0   6  160 #> Mazda RX4 Wag     21.0   6  160 #> Datsun 710        22.8   4  108 #> Hornet 4 Drive    21.4   6  258 #> Hornet Sportabout 18.7   8  360 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 4: A custom ordering (eg, ascending by mpg) rel_order.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[order(df[[1]]), ]) }  rel_order(   mtcars_rel,   list(relexpr_reference(\"mpg\")) ) #> [[1]] #>                    mpg cyl disp  hp #> Hornet Sportabout 18.7   8  360 175 #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Hornet 4 Drive    21.4   6  258 110 #> Datsun 710        22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 5: A custom join rel_join.dfrel <- function(left, right, conds, join, ...) {   left_df <- unclass(left)[[1]]   right_df <- unclass(right)[[1]]    # A real implementation would evaluate the expressions   # defined by the conds argument,   # use different join types based on the join argument,   # and implement the join itself instead of relaying to left_join().   new_dfrel(dplyr::left_join(left_df, right_df)) }  rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel) #> Joining with `by = join_by(mpg)` #> [[1]] #>   mpg cyl disp  hp #> 1  21   6  160 110 #> 2  21   6  160 110 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 6: Limit the maximum rows returned rel_limit.dfrel <- function(rel, n, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[seq_len(n), ]) }  rel_limit(mtcars_rel, 3) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 7: Suppress duplicate rows #  (ignoring row names) rel_distinct.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[!duplicated(df), ]) }  rel_distinct(new_dfrel(mtcars[1:3, 1:4])) #> [[1]] #>             mpg cyl disp  hp #> Mazda RX4  21.0   6  160 110 #> Datsun 710 22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 8: Return column names rel_names.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    names(df) }  rel_names(mtcars_rel) #> [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to a duckplyr data frame — as_duckplyr_df","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"object class duckplyr_df, dplyr verbs mutate(), select() filter()  attempt use DuckDB. possible, original dplyr implementation used.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"","code":"as_duckplyr_df(.data)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":".data data frame tibble transform","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"object class \"duckplyr_df\", inheriting classes .data argument.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"Set DUCKPLYR_FALLBACK_INFO DUCKPLYR_FORCE environment variables control behavior, see config details.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"","code":"tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x56541c9f1958) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4"},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":null,"dir":"Reference","previous_headings":"","what":"Configuration options — config","title":"Configuration options — config","text":"behavior duckplyr can fine-tuned several environment variables, one option.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"options","dir":"Reference","previous_headings":"","what":"Options","title":"Configuration options — config","text":"duckdb.materialize_message: Set FALSE turn diagnostic output duckdb data frame materialization. Currenty set TRUE duckplyr loaded.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"environment-variables","dir":"Reference","previous_headings":"","what":"Environment variables","title":"Configuration options — config","text":"DUCKPLYR_OUTPUT_ORDER: TRUE, row output order preserved. default may change row order dplyr keep stable. DUCKPLYR_FORCE: TRUE, fail duckdb handle request. DUCKPLYR_FALLBACK_INFO: TRUE, print message fallback dplyr occurs duckdb handle request. DUCKPLYR_CHECK_ROUNDTRIP: TRUE, check columns roundtripped perfectly creating relational object data frame, slow, mostly useful debugging. default check roundtrip attributes. DUCKPLYR_EXPERIMENTAL: TRUE, pass experimental = TRUE certain duckdb functions. Currently unused. DUCKPLYR_METHODS_OVERWRITE: TRUE, call methods_overwrite() package loaded. See fallback options related logging uploading fallback events.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Configuration options — config","text":"","code":"# options(duckdb.materialize_message = FALSE) data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   inner_join(data.frame(a = 1:4), by = \"a\") #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Join REGULAR INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>     Projection [a as a_x] #>       r_dataframe_scan(0x56541b38d8f0) #>     Projection [a as a_y] #>       r_dataframe_scan(0x56541b39d1b8) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 1 #> 2 2 #> 3 3  rlang::with_options(duckdb.materialize_message = FALSE, {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     inner_join(data.frame(a = 1:4), by = \"a\") %>%     print() }) #>   a #> 1 1 #> 2 2 #> 3 3  # Sys.setenv(DUCKPLYR_OUTPUT_ORDER = TRUE) data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   inner_join(data.frame(a = 1:4), by = \"a\") #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Join REGULAR INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>     Projection [a as a_x] #>       r_dataframe_scan(0x56541b716a28) #>     Projection [a as a_y] #>       r_dataframe_scan(0x56541b715720) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 1 #> 2 2 #> 3 3  withr::with_envvar(c(DUCKPLYR_OUTPUT_ORDER = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     inner_join(data.frame(a = 1:4), by = \"a\") }) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Order [lhs.___row_number_x ASC, rhs.___row_number_y ASC] #>     Join REGULAR INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>       Projection [a_x as a_x, row_number() OVER () as ___row_number_x] #>         Projection [a as a_x] #>           r_dataframe_scan(0x56541b8a7658) #>       Projection [a_y as a_y, row_number() OVER () as ___row_number_y] #>         Projection [a as a_y] #>           r_dataframe_scan(0x56541b8a6350) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 3 #> 2 2 #> 3 1  # Sys.setenv(DUCKPLYR_FORCE = TRUE) add_one <- function(x) {   x + 1 }  data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   mutate(b = add_one(a)) #> The duckplyr package is configured to fall back to dplyr when it encounters an #> incompatibility. Fallback events can be collected and uploaded for analysis to #> guide future development. By default, no data will be collected or uploaded. #> ℹ A fallback situation just occurred. The following information would have been #>   recorded: #>   {\"version\":\"0.3.2\",\"message\":\"Unknown function: #>   `add_one()`\",\"name\":\"mutate\",\"x\":{\"...1\":\"integer\"},\"args\":{\"dots\":{\"...2\":\"add_one(...1)\"},\".by\":\"NULL\",\".keep\":[\"all\",\"used\",\"unused\",\"none\"]}} #> → Run `duckplyr::fallback_sitrep()` to review the current settings. #> → Run `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 1)` to enable fallback logging, #>   and `Sys.setenv(DUCKPLYR_FALLBACK_VERBOSE = TRUE)` in addition to enable #>   printing of fallback situations to the console. #> → Run `duckplyr::fallback_review()` to review the available reports, and #>   `duckplyr::fallback_upload()` to upload them. #> ℹ See `?duckplyr::fallback()` for details. #> ℹ This message will be displayed once every eight hours. #>   a b #> 1 3 4 #> 2 2 3 #> 3 1 2  try(withr::with_envvar(c(DUCKPLYR_FORCE = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     mutate(b = add_one(a)) })) #> Error in do_translate(expr) : Unknown function: `add_one()`  # Sys.setenv(DUCKPLYR_FALLBACK_INFO = TRUE) withr::with_envvar(c(DUCKPLYR_FALLBACK_INFO = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     mutate(b = add_one(a)) }) #> Error processing with relational. #> Caused by error in `do_translate()` at duckplyr/R/relational.R:318:3: #> ! Unknown function: `add_one()` #>   a b #> 1 3 4 #> 2 2 3 #> 3 1 2"},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":null,"dir":"Reference","previous_headings":"","what":"df_from_csv — df_from_csv","title":"df_from_csv — df_from_csv","text":"functions ingest data file using table function. results transparently converted data frame, data read resulting data frame actually accessed. df_from_csv() reads CSV file using read_csv_auto() table function. duckplyr_df_from_csv() thin wrapper around df_from_csv() calls as_duckplyr_df() output. df_from_parquet() reads Parquet file using read_parquet() table function. duckplyr_df_from_parquet() thin wrapper around df_from_parquet() calls as_duckplyr_df() output. df_to_parquet() writes data frame Parquet file via DuckDB. data frame duckplyr_df, materialization occurs outside R. existing file overwritten. function requires duckdb >= 0.10.0. df_from_file() uses arbitrary table functions read data. See https://duckdb.org/docs/data/overview documentation available functions options. duckplyr_df_from_file() thin wrapper around df_from_file() calls as_duckplyr_df() output.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"df_from_csv — df_from_csv","text":"","code":"df_from_csv(path, ..., options = list(), class = NULL)  duckplyr_df_from_csv(path, ..., options = list(), class = NULL)  df_from_parquet(path, ..., options = list(), class = NULL)  duckplyr_df_from_parquet(path, ..., options = list(), class = NULL)  df_to_parquet(data, path)  df_from_file(path, table_function, ..., options = list(), class = NULL)  duckplyr_df_from_file(   path,   table_function,   ...,   options = list(),   class = NULL )"},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"df_from_csv — df_from_csv","text":"path Path file, directory, set filenames using wildcards. ... dots future extensions must empty. options Arguments DuckDB function indicated table_function. class optional class add data frame. returned object always data frame. Pass class(tibble()) create tibble. data data frame written disk. table_function name table-valued DuckDB function \"read_parquet\", \"read_csv\", \"read_csv_auto\" \"read_json\".","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"df_from_csv — df_from_csv","text":"data frame df_from_file(), duckplyr_df duckplyr_df_from_file(), extended provided class.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"df_from_csv — df_from_csv","text":"","code":"# Create simple CSV file path <- tempfile(\"duckplyr_test_\", fileext = \".csv\") write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)  # Reading is immediate df <- df_from_csv(path)  # Materialization only upon access names(df) #> [1] \"a\" \"b\" df$a #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_csv_auto(/tmp/Rtmp79lNV9/duckplyr_test_106057311593.csv) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (BIGINT) #> - b (VARCHAR) #>  #> [1] 1 2 3  # Return as tibble: df_from_file(   path,   \"read_csv\",   options = list(delim = \",\", auto_detect = TRUE),   class = class(tibble()) ) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_csv(/tmp/Rtmp79lNV9/duckplyr_test_106057311593.csv) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (BIGINT) #> - b (VARCHAR) #>  #> # A tibble: 3 × 2 #>       a b     #>   <dbl> <chr> #> 1     1 d     #> 2     2 e     #> 3     3 f      # Read multiple file at once path2 <- tempfile(\"duckplyr_test_\", fileext = \".csv\") write.csv(data.frame(a = 4:6, b = letters[7:9]), path2, row.names = FALSE)  duckplyr_df_from_csv(file.path(tempdir(), \"duckplyr_test_*.csv\")) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_csv_auto(/tmp/Rtmp79lNV9/duckplyr_test_*.csv) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (BIGINT) #> - b (VARCHAR) #>  #>   a b #> 1 4 g #> 2 5 h #> 3 6 i #> 4 1 d #> 5 2 e #> 6 3 f  unlink(c(path, path2))  # Write a Parquet file: path_parquet <- tempfile(fileext = \".parquet\") df_to_parquet(df, path_parquet)  # With a duckplyr_df, the materialization occurs outside of R: df %>%   as_duckplyr_df() %>%   mutate(b = a + 1) %>%   df_to_parquet(path_parquet)  duckplyr_df_from_parquet(path_parquet) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_parquet(/tmp/Rtmp79lNV9/file1060405fb4b3.parquet) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (DOUBLE) #> - b (DOUBLE) #>  #>   a b #> 1 1 2 #> 2 2 3 #> 3 3 4  unlink(path_parquet)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/duckplyr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","title":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","text":"drop-replacement 'dplyr', powered 'DuckDB' performance. Also defines set generics provide low-level implementer's interface high-level user interface 'dplyr'.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/reference/duckplyr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","text":"Maintainer: Kirill Müller kirill@cynkra.com (ORCID) Authors: Hannes Mühleisen (ORCID) contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":null,"dir":"Reference","previous_headings":"","what":"Fallback to dplyr — fallback","title":"Fallback to dplyr — fallback","text":"duckplyr package aims providing fully compatible drop-replacement dplyr. achieve , carefully selected subset dplyr's operations, R functions, R data types implemented. Whenever duckplyr encounters incompatibility, falls back dplyr. assist future development, fallback situations can logged console local file uploaded analysis. default, duckplyr log upload anything. functions environment variables page control process. fallback_sitrep() prints current settings fallback logging uploading, number reports ready upload, location logs. fallback_review() prints available reports review console. fallback_upload() uploads available reports central server analysis. server hosted AWS reports stored private S3 bucket. authorized personnel access reports. fallback_purge() deletes available reports.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fallback to dplyr — fallback","text":"","code":"fallback_sitrep()  fallback_review(oldest = NULL, newest = NULL, detail = TRUE)  fallback_upload(oldest = NULL, newest = NULL, strict = TRUE)  fallback_purge(oldest = NULL, newest = NULL)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fallback to dplyr — fallback","text":"oldest, newest number oldest newest reports review. specified, reports dispayed. detail Print full content reports. Set FALSE print file names. strict TRUE, function aborts reports fail upload. FALSE, message printed.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fallback to dplyr — fallback","text":"Logging uploading opt-. default, logging, message printed console first time session every 8 hours. following environment variables control logging uploading: DUCKPLYR_FALLBACK_COLLECT controls logging, set 1 greater enable logging. value 0, logging disabled. Future versions duckplyr may start logging additional data thus require higher value enable logging. Set 99 enable logging future versions. Use usethis::edit_r_environ() edit environment file. DUCKPLYR_FALLBACK_VERBOSE controls printing, set TRUE FALSE enable disable printing. value TRUE, message printed console fallback situation. setting relevant logging enabled. DUCKPLYR_FALLBACK_AUTOUPLOAD controls uploading, set 1 greater enable uploading. value 0, uploading disabled. Currently, uploading active value 1 greater. Future versions duckplyr may start logging additional data thus require higher value enable uploading. Set 99 enable uploading future versions. Use usethis::edit_r_environ() edit environment file. DUCKPLYR_FALLBACK_LOG_DIR controls location logs. must point directory (existing ) logs written. default, logs written directory user's cache directory returned tools::R_user_dir(\"duckplyr\", \"cache\"). code related fallback logging uploading fallback.R telemetry.R files.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fallback to dplyr — fallback","text":"","code":"fallback_sitrep() #> The duckplyr package is configured to fall back to dplyr when it encounters an #> incompatibility. Fallback events can be collected and uploaded for analysis to #> guide future development. By default, no data will be collected or uploaded. #> ℹ Fallback logging is not controlled and therefore disabled. Enable it with #>   `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 1)`, disable it with #>   `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 0)`. #> ℹ Fallback uploading is not controlled and therefore disabled. Enable it with #>   `Sys.setenv(DUCKPLYR_FALLBACK_AUTOUPLOAD = 1)`, disable it with #>   `Sys.setenv(DUCKPLYR_FALLBACK_AUTOUPLOAD = 0)`. #> ℹ See `?duckplyr::fallback()` for details."},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Class predicate for duckplyr data frames — is_duckplyr_df","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"Tests input object class \"duckplyr_df\".","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"","code":"is_duckplyr_df(.data)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":".data object test","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"TRUE input object class \"duckplyr_df\", otherwise FALSE.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"","code":"tibble(a = 1:3) %>%   is_duckplyr_df() #> [1] FALSE  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   is_duckplyr_df() #> [1] TRUE"},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":null,"dir":"Reference","previous_headings":"","what":"Forward all dplyr methods to duckplyr — methods_overwrite","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"calling methods_overwrite(), dplyr methods redirected duckplyr duraton session, call methods_restore(). methods_overwrite() function called automatically package loaded environment variable DUCKPLYR_METHODS_OVERWRITE set TRUE.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"","code":"methods_overwrite()  methods_restore()"},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"Called side effects.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"","code":"tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  methods_overwrite() #> ℹ Overwriting dplyr methods with duckplyr methods  tibble(a = 1:3) %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x56541aab7300) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  methods_restore() #> ℹ Restoring dplyr methods  tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational implementer's interface — new_relational","title":"Relational implementer's interface — new_relational","text":"constructor generics described define class helps separating dplyr's user interface actual underlying operations. longer term, help packages implement dplyr interface (dbplyr, dtplyr, arrow similar) focus core details functionality, rather intricacies dplyr's user interface. new_relational() constructs object class \"relational\". Users encouraged provide class argument. typical use case create wrapper function. rel_to_df() extracts data frame representation relational object, used dplyr::collect(). rel_filter() keeps rows match predicate, used dplyr::filter(). rel_project() selects columns creates new columns, used dplyr::select(), dplyr::rename(), dplyr::mutate(), dplyr::relocate(), others. rel_aggregate() combines several rows one, used dplyr::summarize(). rel_order() reorders rows columns expressions, used dplyr::arrange(). rel_join() joins merges two tables, used dplyr::left_join(), dplyr::right_join(), dplyr::inner_join(), dplyr::full_join(), dplyr::cross_join(), dplyr::semi_join(), dplyr::anti_join(). rel_limit() limits number rows table, used utils::head(). rel_distinct() keeps distinct rows table, used dplyr::distinct(). rel_set_intersect() returns rows present tables, used intersect(). rel_set_diff() returns rows present tables, used setdiff(). rel_set_symdiff() returns rows present tables, used dplyr::symdiff(). rel_union_all() returns rows present tables, used dplyr::union_all(). rel_explain() prints explanation plan executed relational object. rel_alias() returns alias name relational object. rel_set_alias() sets alias name relational object. rel_names() returns column names character vector, used colnames().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational implementer's interface — new_relational","text":"","code":"new_relational(..., class = NULL)  rel_to_df(rel, ...)  rel_filter(rel, exprs, ...)  rel_project(rel, exprs, ...)  rel_aggregate(rel, groups, aggregates, ...)  rel_order(rel, orders, ...)  rel_join(   left,   right,   conds,   join = c(\"inner\", \"left\", \"right\", \"outer\", \"cross\", \"semi\", \"anti\"),   join_ref_type = c(\"regular\", \"natural\", \"cross\", \"positional\", \"asof\"),   ... )  rel_limit(rel, n, ...)  rel_distinct(rel, ...)  rel_set_intersect(rel_a, rel_b, ...)  rel_set_diff(rel_a, rel_b, ...)  rel_set_symdiff(rel_a, rel_b, ...)  rel_union_all(rel_a, rel_b, ...)  rel_explain(rel, ...)  rel_alias(rel, ...)  rel_set_alias(rel, alias, ...)  rel_names(rel, ...)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational implementer's interface — new_relational","text":"... Reserved future extensions, must empty. class Classes added front \"relational\" base class. rel, rel_a, rel_b, left, right relational object. exprs list expr objects filter . groups list expressions group . aggregates list expressions aggregates compute. orders list expressions order . conds list expressions use join. join type join. join_ref_type ref type join. n number rows. alias new alias","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational implementer's interface — new_relational","text":"new_relational() returns new relational object. rel_to_df() returns data frame. rel_names() returns character vector. generics return modified relational object.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational implementer's interface — new_relational","text":"","code":"new_dfrel <- function(x) {   stopifnot(is.data.frame(x))   new_relational(list(x), class = \"dfrel\") } mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])  rel_to_df.dfrel <- function(rel, ...) {   unclass(rel)[[1]] } rel_to_df(mtcars_rel) #>                    mpg cyl disp  hp #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Datsun 710        22.8   4  108  93 #> Hornet 4 Drive    21.4   6  258 110 #> Hornet Sportabout 18.7   8  360 175  rel_filter.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the predicates defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, nrow(df))), ]) }  rel_filter(   mtcars_rel,   list(     relexpr_function(       \"gt\",       list(relexpr_reference(\"cyl\"), relexpr_constant(\"6\"))     )   ) ) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_project.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, ncol(df)))]) }  rel_project(   mtcars_rel,   list(relexpr_reference(\"cyl\"), relexpr_reference(\"disp\")) ) #> [[1]] #>                    mpg cyl disp #> Mazda RX4         21.0   6  160 #> Mazda RX4 Wag     21.0   6  160 #> Datsun 710        22.8   4  108 #> Hornet 4 Drive    21.4   6  258 #> Hornet Sportabout 18.7   8  360 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_order.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[order(df[[1]]), ]) }  rel_order(   mtcars_rel,   list(relexpr_reference(\"mpg\")) ) #> [[1]] #>                    mpg cyl disp  hp #> Hornet Sportabout 18.7   8  360 175 #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Hornet 4 Drive    21.4   6  258 110 #> Datsun 710        22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\" rel_join.dfrel <- function(left, right, conds, join, ...) {   left_df <- unclass(left)[[1]]   right_df <- unclass(right)[[1]]    # A real implementation would evaluate the expressions   # defined by the conds argument,   # use different join types based on the join argument,   # and implement the join itself instead of relaying to left_join().   new_dfrel(dplyr::left_join(left_df, right_df)) }  rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel) #> Joining with `by = join_by(mpg)` #> [[1]] #>   mpg cyl disp  hp #> 1  21   6  160 110 #> 2  21   6  160 110 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_limit.dfrel <- function(rel, n, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[seq_len(n), ]) }  rel_limit(mtcars_rel, 3) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_distinct.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[!duplicated(df), ]) }  rel_distinct(new_dfrel(mtcars[1:3, 1:4])) #> [[1]] #>             mpg cyl disp  hp #> Mazda RX4  21.0   6  160 110 #> Datsun 710 22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_names.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    names(df) }  rel_names(mtcars_rel) #> [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational expressions — new_relexpr","title":"Relational expressions — new_relexpr","text":"functions provide backend-agnostic way construct expression trees built column references, constants, functions. subexpressions expression tree can alias. new_relexpr() constructs object class \"relational_relexpr\". used higher-level constructors, users rarely need call directly. relexpr_reference() constructs reference column. relexpr_constant() wraps constant value. relexpr_function() applies function. arguments function list expression objects. relexpr_window() applies function window, similarly SQL clause. relexpr_set_alias() assigns alias expression.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational expressions — new_relexpr","text":"","code":"new_relexpr(x, class = NULL)  relexpr_reference(name, rel = NULL, alias = NULL)  relexpr_constant(val, alias = NULL)  relexpr_function(name, args, alias = NULL)  relexpr_window(   expr,   partitions,   order_bys = list(),   offset_expr = NULL,   default_expr = NULL,   alias = NULL )  relexpr_set_alias(expr, alias = NULL)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational expressions — new_relexpr","text":"x object. class Classes added front \"relational_relexpr\" base class. name name column function reference. rel name relation reference. alias alias new expression. val value use constant expression. args Function arguments, list expr objects. expr expr object. partitions Partitions, list expr objects. order_bys variables order results (list). offset_expr offset relational expression. default_expr default relational expression.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational expressions — new_relexpr","text":"object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\"","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational expressions — new_relexpr","text":"","code":"relexpr_set_alias(   alias = \"my_predicate\",   relexpr_function(     \"<\",     list(       relexpr_reference(\"my_number\"),       relexpr_constant(42)     )   ) ) #> List of 3 #>  $ name : chr \"<\" #>  $ args :List of 2 #>   ..$ :List of 3 #>   .. ..$ name : chr \"my_number\" #>   .. ..$ rel  : NULL #>   .. ..$ alias: NULL #>   .. ..- attr(*, \"class\")= chr [1:2] \"relational_relexpr_reference\" \"relational_relexpr\" #>   ..$ :List of 2 #>   .. ..$ val  : num 42 #>   .. ..$ alias: NULL #>   .. ..- attr(*, \"class\")= chr [1:2] \"relational_relexpr_constant\" \"relational_relexpr\" #>  $ alias: chr \"my_predicate\" #>  - attr(*, \"class\")= chr [1:2] \"relational_relexpr_function\" \"relational_relexpr\""},{"path":"https://duckdblabs.github.io/duckplyr/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. dplyr %>%, across, add_count, add_tally, all_equal, anti_join, arrange, auto_copy, c_across, case_when, collapse, collect, compute, count, cross_join, desc, distinct, , dplyr_col_modify, dplyr_reconstruct, dplyr_row_slice, explain, filter, first, full_join, funs, funs_, group_by, group_data, group_keys, group_map, group_modify, group_rows, group_size, group_vars, group_walk, if_all, if_any, inner_join, intersect, is_grouped_df, join_by, lag, last, lead, left_join, mutate, mutate_all, n, n_distinct, nest_by, nest_join, nth, pull, reframe, relocate, rename, rename_all, rename_at, rename_if, rename_with, right_join, row_number, rows_append, rows_delete, rows_insert, rows_patch, rows_update, rows_upsert, rowwise, same_src, sample_frac, sample_n, select, select_all, select_at, select_if, semi_join, setdiff, setequal, slice, slice_head, slice_max, slice_min, slice_sample, slice_tail, summarise, summarise_all, summarise_at, summarize, symdiff, tally, tbl_vars, tibble, transmute, ungroup, union, union_all, vars, with_groups","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":null,"dir":"Reference","previous_headings":"","what":"Show stats — stats_show","title":"Show stats — stats_show","text":"Prints statistics many calls handled DuckDB. output shows total number requests current session, split fallbacks dplyr requests handled duckdb.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show stats — stats_show","text":"","code":"stats_show()"},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show stats — stats_show","text":"Called side effect.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show stats — stats_show","text":"","code":"stats_show() #> 🛠: 10 #> 🔨:  2 #> 🦆:  8 #> inner_join, mutate, mutate.data.frame  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x56541c811c58) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  stats_show() #> 🛠: 11 #> 🔨:  2 #> 🦆:  9 #> inner_join, mutate, mutate.data.frame"},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-3-2-9009","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.3.2.9009 (2024-05-04)","text":"Update patch. Bump duckdb version (#147).","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-2-9008","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.2.9008 (2024-04-28)","text":"careful detection row names data frame.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-3-2-9008","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.3.2.9008 (2024-04-28)","text":"allow constant patterns grepl(). Explicitly reject calls named arguments now.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"testing-0-3-2-9008","dir":"Changelog","previous_headings":"","what":"Testing","title":"duckplyr 0.3.2.9008 (2024-04-28)","text":"Improve telemetry tests.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-2-9007","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.2.9007 (2024-04-27)","text":"careful detection row names data frame. Always check roundtrip timestamp columns. %% evaluates RHS correct environment. left_join() join functions call auto_copy(). reset expression depth set .","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-3-2-9007","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.3.2.9007 (2024-04-27)","text":"Reduce memory limit revdepchecks.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-2-9006","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.2.9006 (2024-04-26)","text":"Require fallback result contains duplicate column names ignoring case.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-2-9005","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.2.9005 (2024-04-25)","text":"row_number() returns integer. .na(NaN) TRUE. summarise(count = n(), count = n()) creates one column named count.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"testing-0-3-2-9005","dir":"Changelog","previous_headings":"","what":"Testing","title":"duckplyr 0.3.2.9005 (2024-04-25)","text":"Promote equality checks expect_identical() capture differences doubles integers.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-2-9004","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.2.9004 (2024-04-23)","text":"Correctly match NA %%.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-3-2-9004","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.3.2.9004 (2024-04-23)","text":"Update snapshots. Avoid error stats collection.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-3-2-9003","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.3.2.9003 (2024-04-19)","text":"New constructive version.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-3-2-9002","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.3.2.9002 (2024-04-14)","text":"Mention wildcards read multiple files ?df_from_file (@andreranza, #133, #134).","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-2-9001","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.2.9001 (2024-04-12)","text":"Correct wording instructions enabling fallback logging (@TimTaylor, #141).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-0329000-2024-03-17","dir":"Changelog","previous_headings":"","what":"duckplyr 0.3.2.9000 (2024-03-17)","title":"duckplyr 0.3.2.9000 (2024-03-17)","text":"Merge branch ‘cran-0.3.2’.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-032-2024-03-17","dir":"Changelog","previous_headings":"","what":"duckplyr 0.3.2 (2024-03-17)","title":"duckplyr 0.3.2 (2024-03-17)","text":"CRAN release: 2024-03-17","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.2 (2024-03-17)","text":"Run autoupload function checked static analysis (#122).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-3-2","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.3.2 (2024-03-17)","text":"New df_to_parquet() write Parquet, new convenience functions df_from_csv(), duckdb_df_from_csv(), df_from_parquet() duckdb_df_from_parquet() (#87, #89, #96, #128).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-031-2024-03-08","dir":"Changelog","previous_headings":"","what":"duckplyr 0.3.1 (2024-03-08)","title":"duckplyr 0.3.1 (2024-03-08)","text":"CRAN release: 2024-03-10","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.1 (2024-03-08)","text":"Forbid reuse new columns created summarise() (#72, #106). summarise() longer restores subclass. Disambiguate computation log10() log(). Fix division zero positive negative numbers.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-3-1","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.3.1 (2024-03-08)","text":"New fallback_sitrep() related functionality collecting telemetry data (#102, #107, #110, #111, #115). data collected default, message displayed per session every eight hours. Opt opt setting environment variables. Implement group_by() methods collect fallback information (#94, #104, #105). Set memory limit temporary directory duckdb. Implement suppressWarnings() identity function. Prefer cli::cli_abort() stop() rlang::abort() (#114). Translate .data$.env$. Strict checks column class, supporting integer, numeric, logical, Date, POSIXct, difftime now. environment variable DUCKPLYR_METHODS_OVERWRITE set TRUE, loading duckplyr automatically calls methods_overwrite().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"internal-0-3-1","dir":"Changelog","previous_headings":"","what":"Internal","title":"duckplyr 0.3.1 (2024-03-08)","text":"Better duckdb tests. Use standalone purrr dplyr compatibility.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"testing-0-3-1","dir":"Changelog","previous_headings":"","what":"Testing","title":"duckplyr 0.3.1 (2024-03-08)","text":"Add tests correct base log() log10().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-3-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.3.1 (2024-03-08)","text":"methods_overwrite() methods_restore() show message.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-030-2023-12-10","dir":"Changelog","previous_headings":"","what":"duckplyr 0.3.0 (2023-12-10)","title":"duckplyr 0.3.0 (2023-12-10)","text":"CRAN release: 2023-12-11","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.0 (2023-12-10)","text":"grepl(x = NA) gives correct results. Fix auto_copy() non-data-frame input. Add output order preservation filters. distinct() now preserves order corner cases (#77, #78). Consistent computation log(0) log(-1) (#75, #76).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-3-0","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.3.0 (2023-12-10)","text":"allow constants mutate() actually representable duckdb (#73). Avoid translating ifelse(), support if_else() (#79).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-3-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.3.0 (2023-12-10)","text":"Separate explain new relational examples (@wibeasley, #84).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"testing-0-3-0","dir":"Changelog","previous_headings":"","what":"Testing","title":"duckplyr 0.3.0 (2023-12-10)","text":"Add test TPC-H queries can processed.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-3-0","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.3.0 (2023-12-10)","text":"Sync dplyr 1.1.4 (#82). Remove dplyr_reconstruct() method (#48). Render README. Fix code generated meta_replay(). Bump constructive dependency. Fix output order arrange() case ties. Update duckdb tests. implement newer slice_sample(), sample_n() sample_frac() (#74). Sync generated files (#71).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-023-2023-11-08","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.3 (2023-11-08)","title":"duckplyr 0.2.3 (2023-11-08)","text":"CRAN release: 2023-11-08","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"performance-0-2-3","dir":"Changelog","previous_headings":"","what":"Performance","title":"duckplyr 0.2.3 (2023-11-08)","text":"Join using DISTINCT faster execution (duckdb/duckdb-r#41, #68).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-2-3","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.2.3 (2023-11-08)","text":"Add stability README output (@maelle, #62, #65).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-022-2023-10-16","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.2 (2023-10-16)","title":"duckplyr 0.2.2 (2023-10-16)","text":"CRAN release: 2023-10-16","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-2-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.2.2 (2023-10-16)","text":"summarise() keeps \"duckplyr_df\" class (#63, #64). Fix compatibility duckdb >= 0.9.1.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-2-2","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.2.2 (2023-10-16)","text":"Skip tests give different output dev tidyselect. Import utils::globalVariables().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-2-2","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.2.2 (2023-10-16)","text":"Small README improvements (@maelle, #34, #57). Fix 301 README.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-021-2023-09-16","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.1 (2023-09-16)","title":"duckplyr 0.2.1 (2023-09-16)","text":"CRAN release: 2023-09-17 Improve documentation. Work around problem dplyr_reconstruct() R 4.3. Rename duckdb_from_file() df_from_file(). Unexport private duckdb_rel_from_df(), rel_from_df(), wrap_df() wrap_integer(). Reexport %>% tibble().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-020-2023-09-10","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.0 (2023-09-10)","title":"duckplyr 0.2.0 (2023-09-10)","text":"CRAN release: 2023-09-10 Implement relational API DuckDB.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-010-2023-07-03","dir":"Changelog","previous_headings":"","what":"duckplyr 0.1.0 (2023-07-03)","title":"duckplyr 0.1.0 (2023-07-03)","text":"CRAN release: 2023-07-07","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-1-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.1.0 (2023-07-03)","text":"Fix examples.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-1-0","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.1.0 (2023-07-03)","text":"Add CRAN install instructions. Satisfy R CMD check. Document argument. Error NOTE. Remove relexpr_window() now.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-1-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.1.0 (2023-07-03)","text":"Clean reference.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"uncategorized-0-1-0","dir":"Changelog","previous_headings":"","what":"Uncategorized","title":"duckplyr 0.1.0 (2023-07-03)","text":"Initial version, exporting: - new_relational() construct objects class \"relational\" - Generics rel_aggregate(), rel_distinct(), rel_filter(), rel_join(), rel_limit(), rel_names(), rel_order(), rel_project(), rel_set_diff(), rel_set_intersect(), rel_set_symdiff(), rel_to_df(), rel_union_all() - new_relexpr() construct objects class \"relational_relexpr\" - Expression builders relexpr_constant(), relexpr_function(), relexpr_reference(), relexpr_set_alias(), relexpr_window()","code":""}]
