[{"path":"https://duckdblabs.github.io/duckplyr/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to duckplyr","title":"Contributing to duckplyr","text":"outlines propose change duckplyr. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to duckplyr","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to duckplyr","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to duckplyr","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"duckdblabs/duckplyr\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. Please edit NEWS.md.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to duckplyr","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/CONTRIBUTING.html","id":"new-translations-for-functions","dir":"","previous_headings":"","what":"New translations for functions","title":"Contributing to duckplyr","text":"functions used dplyr verbs, translations must provided. code lives translate.R . New translations must change code two places: switch() rel_find_call() needs new entry, together package home function. top 60 functions, ranked importance, already part switch(), comment implemented yet. actual translation must implemented rel_translate_lang(). easy functions similar functions already translated, harder others. part code clear yet, particular, argument matching name available functions generalized. Add test new translation mutate = section test_extra_arg_map 00-funs.R. (point want specific tests translations, now, .) Run 03-tests.R, commit changes generated code version control.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to duckplyr","text":"Please note duckplyr project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 duckplyr authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hannes Mühleisen. Author. Kirill Müller. Author, maintainer. Posit Software, PBC. Copyright holder, funder.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mühleisen H, Müller K (2024). duckplyr: 'DuckDB'-Backed Version 'dplyr'. R package version 0.4.0.9003, https://github.com/duckdblabs/duckplyr, https://duckdblabs.github.io/duckplyr/.","code":"@Manual{,   title = {duckplyr: A 'DuckDB'-Backed Version of 'dplyr'},   author = {Hannes Mühleisen and Kirill Müller},   year = {2024},   note = {R package version 0.4.0.9003, https://github.com/duckdblabs/duckplyr},   url = {https://duckdblabs.github.io/duckplyr/}, }"},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"duckplyr","dir":"","previous_headings":"","what":"A DuckDB-Backed Version of dplyr","title":"A DuckDB-Backed Version of dplyr","text":"goal duckplyr R package provide drop-replacement dplyr uses DuckDB backend fast operation. DuckDB -process SQL OLAP database management system, dplyr grammar data manipulation tidyverse. duckplyr also defines set generics provide low-level implementer’s interface dplyr’s high-level user interface.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A DuckDB-Backed Version of dplyr","text":"Install duckplyr CRAN : can also install development version duckplyr R-universe: GitHub :","code":"install.packages(\"duckplyr\") install.packages(\"duckplyr\", repos = c(\"https://duckdblabs.r-universe.dev\", \"https://cloud.r-project.org\")) # install.packages(\"pak\", repos = sprintf(\"https://r-lib.github.io/p/pak/stable/%s/%s/%s\", .Platform$pkgType, R.Version()$os, R.Version()$arch)) pak::pak(\"duckdblabs/duckplyr\")"},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"A DuckDB-Backed Version of dplyr","text":"two ways use duckplyr. enable duckplyr individual data frames, use duckplyr::as_duckplyr_df() first step pipe, without attaching package. calling library(duckplyr), overwrites dplyr methods automatically enabled entire session without call as_duckplyr_df(). turn , call methods_restore(). examples illustrate methods. See also companion demo repository use case large dataset.","code":"library(conflicted) library(dplyr) conflict_prefer(\"filter\", \"dplyr\") #> [conflicted] Will prefer dplyr::filter over any #> other package."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"usage-for-individual-data-frames","dir":"","previous_headings":"Examples","what":"Usage for individual data frames","title":"A DuckDB-Backed Version of dplyr","text":"example illustrates usage duckplyr individual data frames. Use duckplyr::as_duckplyr_df() enable processing duckdb: result data frame tibble, class. duckdb responsible eventually carrying operations. Despite late filter, summary computed Gentoo species. data frame operations supported. Computation happens upon first request. computation carried , results available immediately:","code":"out <-   palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   duckplyr::as_duckplyr_df() %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\") class(out) #> [1] \"duckplyr_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" names(out) #> [1] \"species\"        \"sex\"            \"mean_bill_area\" out %>%   explain() #> ┌───────────────────────────┐ #> │          ORDER_BY         │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          ORDERS:          │ #> │      dataframe_42_42      │ #> │    42.___row_number ASC   │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │           FILTER          │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │r_base::!=(species, 'Gentoo│ #> │             ')            │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │           EC: 34          │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │         PROJECTION        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │             #0            │ #> │             #1            │ #> │             #2            │ #> │             #3            │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │      STREAMING_WINDOW     │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │    ROW_NUMBER() OVER ()   │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │          ORDER_BY         │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          ORDERS:          │ #> │      dataframe_42_42      │ #> │    42.___row_number ASC   │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │       HASH_GROUP_BY       │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │             #0            │ #> │             #1            │ #> │          min(#2)          │ #> │          mean(#3)         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │         PROJECTION        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │            sex            │ #> │       ___row_number       │ #> │         bill_area         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │         PROJECTION        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │             #0            │ #> │             #1            │ #> │             #2            │ #> │             #3            │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │      STREAMING_WINDOW     │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │    ROW_NUMBER() OVER ()   │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │         PROJECTION        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │            sex            │ #> │         bill_area         │ #> └─────────────┬─────────────┘                              #> ┌─────────────┴─────────────┐ #> │     R_DATAFRAME_SCAN      │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │         data.frame        │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          species          │ #> │       bill_length_mm      │ #> │       bill_depth_mm       │ #> │            sex            │ #> │   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   │ #> │          EC: 344          │ #> └───────────────────────────┘ out$mean_bill_area #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [species as species, sex as sex, mean_bill_area as mean_bill_area] #>   Order [___row_number ASC] #>     Filter [!=(species, 'Gentoo')] #>       Projection [species as species, sex as sex, mean_bill_area as mean_bill_area, row_number() OVER () as ___row_number] #>         Projection [species as species, sex as sex, mean_bill_area as mean_bill_area] #>           Order [___row_number ASC] #>             Aggregate [species, sex, min(___row_number), mean(bill_area)] #>               Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, bill_area as bill_area, row_number() OVER () as ___row_number] #>                 Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, *(bill_length_mm, bill_depth_mm) as bill_area] #>                   r_dataframe_scan(0xdeadbeef) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - species (VARCHAR) #> - sex (VARCHAR) #> - mean_bill_area (DOUBLE) #>  #> [1] 770.2627 656.8523 694.9360 819.7503 984.2279 out #> # A tibble: 5 × 3 #>   species   sex    mean_bill_area #>   <chr>     <chr>           <dbl> #> 1 Adelie    male             770. #> 2 Adelie    female           657. #> 3 Adelie    NA               695. #> 4 Chinstrap female           820. #> 5 Chinstrap male             984."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"session-wide-usage","dir":"","previous_headings":"Examples","what":"Session-wide usage","title":"A DuckDB-Backed Version of dplyr","text":"example illustrates usage duckplyr data frames R session. Use library(duckplyr) duckplyr::methods_overwrite() overwrite dplyr methods enable processing duckdb data frames: query , without as_duckplyr_df(): result plain tibble now: Querying number rows also starts computation: Restart R, call duckplyr::methods_restore() revert default dplyr implementation. dplyr active :","code":"duckplyr::methods_overwrite() #> ✔ Overwriting dplyr methods with duckplyr methods. #> ℹ Turn off with `duckplyr::methods_restore()`. out <-   palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\") class(out) #> [1] \"tbl_df\"     \"tbl\"        \"data.frame\" nrow(out) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [species as species, sex as sex, mean_bill_area as mean_bill_area] #>   Order [___row_number ASC] #>     Filter [!=(species, 'Gentoo')] #>       Projection [species as species, sex as sex, mean_bill_area as mean_bill_area, row_number() OVER () as ___row_number] #>         Projection [species as species, sex as sex, mean_bill_area as mean_bill_area] #>           Order [___row_number ASC] #>             Aggregate [species, sex, min(___row_number), mean(bill_area)] #>               Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, bill_area as bill_area, row_number() OVER () as ___row_number] #>                 Projection [species as species, island as island, bill_length_mm as bill_length_mm, bill_depth_mm as bill_depth_mm, flipper_length_mm as flipper_length_mm, body_mass_g as body_mass_g, sex as sex, \"year\" as year, *(bill_length_mm, bill_depth_mm) as bill_area] #>                   r_dataframe_scan(0xdeadbeef) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - species (VARCHAR) #> - sex (VARCHAR) #> - mean_bill_area (DOUBLE) #> [1] 5 duckplyr::methods_restore() #> ℹ Restoring dplyr methods. palmerpenguins::penguins %>%   # CAVEAT: factor columns are not supported yet   mutate(across(where(is.factor), as.character)) %>%   mutate(bill_area = bill_length_mm * bill_depth_mm) %>%   summarize(.by = c(species, sex), mean_bill_area = mean(bill_area)) %>%   filter(species != \"Gentoo\") #> # A tibble: 5 × 3 #>   species   sex    mean_bill_area #>   <chr>     <chr>           <dbl> #> 1 Adelie    male             770. #> 2 Adelie    female           657. #> 3 Adelie    NA                NA  #> 4 Chinstrap female           820. #> 5 Chinstrap male             984."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"telemetry","dir":"","previous_headings":"","what":"Telemetry","title":"A DuckDB-Backed Version of dplyr","text":"like guide efforts towards improving duckplyr, focusing features impact. end, duckplyr collects uploads telemetry data, permitted user. data collected contains: package version error message input data frames, structure included (column types ), column names data first time package encounters unsupported function, data type, operation, instructions printed console.","code":"palmerpenguins::penguins %>%   duckplyr::as_duckplyr_df() %>%   transmute(bill_area = bill_length_mm * bill_depth_mm) %>%   head(3) #> The duckplyr package is configured to fall back to dplyr when it encounters an #> incompatibility. Fallback events can be collected and uploaded for analysis to #> guide future development. By default, no data will be collected or uploaded. #> ℹ A fallback situation just occurred. The following information would have been #>   recorded: #>   {\"version\":\"0.4.0\",\"message\":\"Can't convert columns of class <factor> to #>   relational. Affected #>   column:\\n`...1`.\",\"name\":\"transmute\",\"x\":{\"...1\":\"factor\",\"...2\":\"factor\",\"...3\":\"numeric\",\"...4\":\"numeric\",\"...5\":\"integer\",\"...6\":\"integer\",\"...7\":\"factor\",\"...8\":\"integer\"},\"args\":{\"dots\":{\"...9\":\"...3 #>   * ...4\"}}} #> → Run `duckplyr::fallback_sitrep()` to review the current settings. #> → Run `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 1)` to enable fallback logging, #>   and `Sys.setenv(DUCKPLYR_FALLBACK_VERBOSE = TRUE)` in addition to enable #>   printing of fallback situations to the console. #> → Run `duckplyr::fallback_review()` to review the available reports, and #>   `duckplyr::fallback_upload()` to upload them. #> ℹ See `?duckplyr::fallback()` for details. #> ℹ This message will be displayed once every eight hours. #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Limit 3 #>   r_dataframe_scan(0xdeadbeef) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - bill_area (DOUBLE) #>  #> # A tibble: 3 × 1 #>   bill_area #>       <dbl> #> 1      731. #> 2      687. #> 3      725."},{"path":"https://duckdblabs.github.io/duckplyr/index.html","id":"extensibility","dir":"","previous_headings":"","what":"Extensibility","title":"A DuckDB-Backed Version of dplyr","text":"package also provides generics, packages may implement methods.","code":"library(duckplyr) #> ✔ Overwriting dplyr methods with duckplyr methods. #> ℹ Turn off with `duckplyr::methods_restore()`. # Create a relational to be used by examples below new_dfrel <- function(x) {   stopifnot(is.data.frame(x))   new_relational(list(x), class = \"dfrel\") } mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])  # Example 1: return a data.frame rel_to_df.dfrel <- function(rel, ...) {   unclass(rel)[[1]] } rel_to_df(mtcars_rel) #>                    mpg cyl disp  hp #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Datsun 710        22.8   4  108  93 #> Hornet 4 Drive    21.4   6  258 110 #> Hornet Sportabout 18.7   8  360 175  # Example 2: A (random) filter rel_filter.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the predicates defined   # by the exprs argument   new_dfrel(df[sample.int(nrow(df), 3, replace = TRUE), ]) }  rel_filter(   mtcars_rel,   list(     relexpr_function(       \"gt\",       list(relexpr_reference(\"cyl\"), relexpr_constant(\"6\"))     )   ) ) #> [[1]] #>                  mpg cyl disp  hp #> Mazda RX4 Wag   21.0   6  160 110 #> Mazda RX4 Wag.1 21.0   6  160 110 #> Datsun 710      22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 3: A custom projection rel_project.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, ncol(df)))]) }  rel_project(   mtcars_rel,   list(relexpr_reference(\"cyl\"), relexpr_reference(\"disp\")) ) #> [[1]] #>                    mpg cyl disp #> Mazda RX4         21.0   6  160 #> Mazda RX4 Wag     21.0   6  160 #> Datsun 710        22.8   4  108 #> Hornet 4 Drive    21.4   6  258 #> Hornet Sportabout 18.7   8  360 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 4: A custom ordering (eg, ascending by mpg) rel_order.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[order(df[[1]]), ]) }  rel_order(   mtcars_rel,   list(relexpr_reference(\"mpg\")) ) #> [[1]] #>                    mpg cyl disp  hp #> Hornet Sportabout 18.7   8  360 175 #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Hornet 4 Drive    21.4   6  258 110 #> Datsun 710        22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 5: A custom join rel_join.dfrel <- function(left, right, conds, join, ...) {   left_df <- unclass(left)[[1]]   right_df <- unclass(right)[[1]]    # A real implementation would evaluate the expressions   # defined by the conds argument,   # use different join types based on the join argument,   # and implement the join itself instead of relaying to left_join().   new_dfrel(dplyr::left_join(left_df, right_df)) }  rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel) #> Joining with `by = join_by(mpg)` #> Joining with `by = join_by(mpg)` #> [[1]] #>   mpg cyl disp  hp #> 1  21   6  160 110 #> 2  21   6  160 110 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 6: Limit the maximum rows returned rel_limit.dfrel <- function(rel, n, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[seq_len(n), ]) }  rel_limit(mtcars_rel, 3) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 7: Suppress duplicate rows #  (ignoring row names) rel_distinct.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[!duplicated(df), ]) }  rel_distinct(new_dfrel(mtcars[1:3, 1:4])) #> [[1]] #>             mpg cyl disp  hp #> Mazda RX4  21.0   6  160 110 #> Datsun 710 22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  # Example 8: Return column names rel_names.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    names(df) }  rel_names(mtcars_rel) #> [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to a duckplyr data frame — as_duckplyr_df","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"object class duckplyr_df, dplyr verbs mutate(), select() filter()  attempt use DuckDB. possible, original dplyr implementation used.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"","code":"as_duckplyr_df(.data)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":".data data frame tibble transform","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"object class \"duckplyr_df\", inheriting classes .data argument.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"Set DUCKPLYR_FALLBACK_INFO DUCKPLYR_FORCE environment variables control behavior, see config details.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/as_duckplyr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to a duckplyr data frame — as_duckplyr_df","text":"","code":"tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x5561e7be56f0) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4"},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":null,"dir":"Reference","previous_headings":"","what":"Configuration options — config","title":"Configuration options — config","text":"behavior duckplyr can fine-tuned several environment variables, one option.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"options","dir":"Reference","previous_headings":"","what":"Options","title":"Configuration options — config","text":"duckdb.materialize_message: Set FALSE turn diagnostic output duckdb data frame materialization. Currenty set TRUE duckplyr loaded.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"environment-variables","dir":"Reference","previous_headings":"","what":"Environment variables","title":"Configuration options — config","text":"DUCKPLYR_OUTPUT_ORDER: TRUE, row output order preserved. default may change row order dplyr keep stable. DUCKPLYR_FORCE: TRUE, fail duckdb handle request. DUCKPLYR_FALLBACK_INFO: TRUE, print message fallback dplyr occurs duckdb handle request. DUCKPLYR_CHECK_ROUNDTRIP: TRUE, check columns roundtripped perfectly creating relational object data frame, slow, mostly useful debugging. default check roundtrip attributes. DUCKPLYR_EXPERIMENTAL: TRUE, pass experimental = TRUE certain duckdb functions. Currently unused. DUCKPLYR_METHODS_OVERWRITE: TRUE, call methods_overwrite() package loaded. See fallback options related logging uploading fallback events.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/config.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Configuration options — config","text":"","code":"# options(duckdb.materialize_message = FALSE) data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   inner_join(data.frame(a = 1:4), by = \"a\") #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Join REGULAR INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>     Projection [a as a_x] #>       r_dataframe_scan(0x5561e65f12e8) #>     Projection [a as a_y] #>       r_dataframe_scan(0x5561e6600948) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 1 #> 2 2 #> 3 3  rlang::with_options(duckdb.materialize_message = FALSE, {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     inner_join(data.frame(a = 1:4), by = \"a\") %>%     print() }) #>   a #> 1 1 #> 2 2 #> 3 3  # Sys.setenv(DUCKPLYR_OUTPUT_ORDER = TRUE) data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   inner_join(data.frame(a = 1:4), by = \"a\") #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Join REGULAR INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>     Projection [a as a_x] #>       r_dataframe_scan(0x5561e69de238) #>     Projection [a as a_y] #>       r_dataframe_scan(0x5561e69dcf68) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 1 #> 2 2 #> 3 3  withr::with_envvar(c(DUCKPLYR_OUTPUT_ORDER = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     inner_join(data.frame(a = 1:4), by = \"a\") }) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [___coalesce(lhs.a_x, rhs.a_y) as a] #>   Order [lhs.___row_number_x ASC, rhs.___row_number_y ASC] #>     Join REGULAR INNER ___eq_na_matches_na(lhs.a_x, rhs.a_y) #>       Projection [a_x as a_x, row_number() OVER () as ___row_number_x] #>         Projection [a as a_x] #>           r_dataframe_scan(0x5561e6b7a030) #>       Projection [a_y as a_y, row_number() OVER () as ___row_number_y] #>         Projection [a as a_y] #>           r_dataframe_scan(0x5561e6b8e3b0) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #>  #>   a #> 1 3 #> 2 2 #> 3 1  # Sys.setenv(DUCKPLYR_FORCE = TRUE) add_one <- function(x) {   x + 1 }  data.frame(a = 3:1) %>%   as_duckplyr_df() %>%   mutate(b = add_one(a)) #> The duckplyr package is configured to fall back to dplyr when it encounters an #> incompatibility. Fallback events can be collected and uploaded for analysis to #> guide future development. By default, no data will be collected or uploaded. #> ℹ A fallback situation just occurred. The following information would have been #>   recorded: #>   {\"version\":\"0.4.0\",\"message\":\"No translation for function #>   `add_one`.\",\"name\":\"mutate\",\"x\":{\"...1\":\"integer\"},\"args\":{\"dots\":{\"...2\":\"add_one(...1)\"},\".by\":\"NULL\",\".keep\":[\"all\",\"used\",\"unused\",\"none\"]}} #> → Run `duckplyr::fallback_sitrep()` to review the current settings. #> → Run `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 1)` to enable fallback logging, #>   and `Sys.setenv(DUCKPLYR_FALLBACK_VERBOSE = TRUE)` in addition to enable #>   printing of fallback situations to the console. #> → Run `duckplyr::fallback_review()` to review the available reports, and #>   `duckplyr::fallback_upload()` to upload them. #> ℹ See `?duckplyr::fallback()` for details. #> ℹ This message will be displayed once every eight hours. #>   a b #> 1 3 4 #> 2 2 3 #> 3 1 2  try(withr::with_envvar(c(DUCKPLYR_FORCE = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     mutate(b = add_one(a)) })) #> Error in rel_find_call(expr[[1]], env) :  #>   No translation for function `add_one`.  # Sys.setenv(DUCKPLYR_FALLBACK_INFO = TRUE) withr::with_envvar(c(DUCKPLYR_FALLBACK_INFO = \"TRUE\"), {   data.frame(a = 3:1) %>%     as_duckplyr_df() %>%     mutate(b = add_one(a)) }) #> Error processing with relational. #> Caused by error in `rel_find_call()` at duckplyr/R/translate.R:131:3: #> ! No translation for function `add_one`. #>   a b #> 1 3 4 #> 2 2 3 #> 3 1 2"},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":null,"dir":"Reference","previous_headings":"","what":"df_from_csv — df_from_csv","title":"df_from_csv — df_from_csv","text":"functions ingest data file using table function. results transparently converted data frame, data read resulting data frame actually accessed. df_from_csv() reads CSV file using read_csv_auto() table function. duckplyr_df_from_csv() thin wrapper around df_from_csv() calls as_duckplyr_df() output. df_from_parquet() reads Parquet file using read_parquet() table function. duckplyr_df_from_parquet() thin wrapper around df_from_parquet() calls as_duckplyr_df() output. df_to_parquet() writes data frame Parquet file via DuckDB. data frame duckplyr_df, materialization occurs outside R. existing file overwritten. function requires duckdb >= 0.10.0. df_from_file() uses arbitrary table functions read data. See https://duckdb.org/docs/data/overview documentation available functions options. duckplyr_df_from_file() thin wrapper around df_from_file() calls as_duckplyr_df() output.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"df_from_csv — df_from_csv","text":"","code":"df_from_csv(path, ..., options = list(), class = NULL)  duckplyr_df_from_csv(path, ..., options = list(), class = NULL)  df_from_parquet(path, ..., options = list(), class = NULL)  duckplyr_df_from_parquet(path, ..., options = list(), class = NULL)  df_to_parquet(data, path)  df_from_file(path, table_function, ..., options = list(), class = NULL)  duckplyr_df_from_file(   path,   table_function,   ...,   options = list(),   class = NULL )"},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"df_from_csv — df_from_csv","text":"path Path file, directory, set filenames using wildcards. ... dots future extensions must empty. options Arguments DuckDB function indicated table_function. class optional class add data frame. returned object always data frame. Pass class(tibble()) create tibble. data data frame written disk. table_function name table-valued DuckDB function \"read_parquet\", \"read_csv\", \"read_csv_auto\" \"read_json\".","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"df_from_csv — df_from_csv","text":"data frame df_from_file(), duckplyr_df duckplyr_df_from_file(), extended provided class.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"df_from_csv — df_from_csv","text":"read multiple files, pass wildcard path argument, use code form:","code":"files %>%   purrr::map(df_from_file, table_function = \"...\") %>%   purrr::reduce(union_all)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/df_from_file.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"df_from_csv — df_from_csv","text":"","code":"# Create simple CSV file path <- tempfile(\"duckplyr_test_\", fileext = \".csv\") write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)  # Reading is immediate df <- df_from_csv(path)  # Materialization only upon access names(df) #> [1] \"a\" \"b\" df$a #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_csv_auto(/tmp/RtmpvM277l/duckplyr_test_f71106eeed4.csv) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (BIGINT) #> - b (VARCHAR) #>  #> [1] 1 2 3  # Return as tibble: df_from_file(   path,   \"read_csv\",   options = list(delim = \",\", auto_detect = TRUE),   class = class(tibble()) ) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_csv(/tmp/RtmpvM277l/duckplyr_test_f71106eeed4.csv) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (BIGINT) #> - b (VARCHAR) #>  #> # A tibble: 3 × 2 #>       a b     #>   <dbl> <chr> #> 1     1 d     #> 2     2 e     #> 3     3 f      # Read multiple file at once path2 <- tempfile(\"duckplyr_test_\", fileext = \".csv\") write.csv(data.frame(a = 4:6, b = letters[7:9]), path2, row.names = FALSE)  duckplyr_df_from_csv(file.path(tempdir(), \"duckplyr_test_*.csv\")) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_csv_auto(/tmp/RtmpvM277l/duckplyr_test_*.csv) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (BIGINT) #> - b (VARCHAR) #>  #>   a b #> 1 1 d #> 2 2 e #> 3 3 f #> 4 4 g #> 5 5 h #> 6 6 i  unlink(c(path, path2))  # Write a Parquet file: path_parquet <- tempfile(fileext = \".parquet\") df_to_parquet(df, path_parquet)  # With a duckplyr_df, the materialization occurs outside of R: df %>%   as_duckplyr_df() %>%   mutate(b = a + 1) %>%   df_to_parquet(path_parquet)  duckplyr_df_from_parquet(path_parquet) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> read_parquet(/tmp/RtmpvM277l/filef711a4047ec.parquet) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (DOUBLE) #> - b (DOUBLE) #>  #>   a b #> 1 1 2 #> 2 2 3 #> 3 3 4  unlink(path_parquet)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/duckplyr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","title":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","text":"drop-replacement 'dplyr', powered 'DuckDB' performance. Also defines set generics provide low-level implementer's interface high-level user interface 'dplyr'.","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/reference/duckplyr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"duckplyr: A 'DuckDB'-Backed Version of 'dplyr' — duckplyr-package","text":"Maintainer: Kirill Müller kirill@cynkra.com (ORCID) Authors: Hannes Mühleisen (ORCID) contributors: Posit Software, PBC [copyright holder, funder]","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":null,"dir":"Reference","previous_headings":"","what":"Fallback to dplyr — fallback","title":"Fallback to dplyr — fallback","text":"duckplyr package aims providing fully compatible drop-replacement dplyr. achieve , carefully selected subset dplyr's operations, R functions, R data types implemented. Whenever duckplyr encounters incompatibility, falls back dplyr. assist future development, fallback situations can logged console local file uploaded analysis. default, duckplyr log upload anything. functions environment variables page control process. fallback_sitrep() prints current settings fallback logging uploading, number reports ready upload, location logs. fallback_review() prints available reports review console. fallback_upload() uploads available reports central server analysis. server hosted AWS reports stored private S3 bucket. authorized personnel access reports. fallback_purge() deletes available reports.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fallback to dplyr — fallback","text":"","code":"fallback_sitrep()  fallback_review(oldest = NULL, newest = NULL, detail = TRUE)  fallback_upload(oldest = NULL, newest = NULL, strict = TRUE)  fallback_purge(oldest = NULL, newest = NULL)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fallback to dplyr — fallback","text":"oldest, newest number oldest newest reports review. specified, reports dispayed. detail Print full content reports. Set FALSE print file names. strict TRUE, function aborts reports fail upload. FALSE, message printed.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fallback to dplyr — fallback","text":"Logging uploading opt-. default, logging, message printed console first time session every 8 hours. following environment variables control logging uploading: DUCKPLYR_FALLBACK_COLLECT controls logging, set 1 greater enable logging. value 0, logging disabled. Future versions duckplyr may start logging additional data thus require higher value enable logging. Set 99 enable logging future versions. Use usethis::edit_r_environ() edit environment file. DUCKPLYR_FALLBACK_VERBOSE controls printing, set TRUE FALSE enable disable printing. value TRUE, message printed console fallback situation. setting relevant logging enabled. DUCKPLYR_FALLBACK_AUTOUPLOAD controls uploading, set 1 greater enable uploading. value 0, uploading disabled. Currently, uploading active value 1 greater. Future versions duckplyr may start logging additional data thus require higher value enable uploading. Set 99 enable uploading future versions. Use usethis::edit_r_environ() edit environment file. DUCKPLYR_FALLBACK_LOG_DIR controls location logs. must point directory (existing ) logs written. default, logs written directory user's cache directory returned tools::R_user_dir(\"duckplyr\", \"cache\"). code related fallback logging uploading fallback.R telemetry.R files.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/fallback.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fallback to dplyr — fallback","text":"","code":"fallback_sitrep() #> The duckplyr package is configured to fall back to dplyr when it encounters an #> incompatibility. Fallback events can be collected and uploaded for analysis to #> guide future development. By default, no data will be collected or uploaded. #> ℹ Fallback logging is not controlled and therefore disabled. Enable it with #>   `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 1)`, disable it with #>   `Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 0)`. #> ℹ Fallback uploading is not controlled and therefore disabled. Enable it with #>   `Sys.setenv(DUCKPLYR_FALLBACK_AUTOUPLOAD = 1)`, disable it with #>   `Sys.setenv(DUCKPLYR_FALLBACK_AUTOUPLOAD = 0)`. #> ℹ See `?duckplyr::fallback()` for details."},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Class predicate for duckplyr data frames — is_duckplyr_df","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"Tests input object class \"duckplyr_df\".","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"","code":"is_duckplyr_df(.data)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":".data object test","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"TRUE input object class \"duckplyr_df\", otherwise FALSE.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/is_duckplyr_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class predicate for duckplyr data frames — is_duckplyr_df","text":"","code":"tibble(a = 1:3) %>%   is_duckplyr_df() #> [1] FALSE  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   is_duckplyr_df() #> [1] TRUE"},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":null,"dir":"Reference","previous_headings":"","what":"Forward all dplyr methods to duckplyr — methods_overwrite","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"calling methods_overwrite(), dplyr methods redirected duckplyr duraton session, call methods_restore(). methods_overwrite() function called automatically package loaded environment variable DUCKPLYR_METHODS_OVERWRITE set TRUE.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"","code":"methods_overwrite()  methods_restore()"},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"Called side effects.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/methods_overwrite.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Forward all dplyr methods to duckplyr — methods_overwrite","text":"","code":"tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  methods_overwrite() #> ✔ Overwriting dplyr methods with duckplyr methods. #> ℹ Turn off with `duckplyr::methods_restore()`.  tibble(a = 1:3) %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x5561e3022bf0) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  methods_restore() #> ℹ Restoring dplyr methods.  tibble(a = 1:3) %>%   mutate(b = a + 1) #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational implementer's interface — new_relational","title":"Relational implementer's interface — new_relational","text":"constructor generics described define class helps separating dplyr's user interface actual underlying operations. longer term, help packages implement dplyr interface (dbplyr, dtplyr, arrow similar) focus core details functionality, rather intricacies dplyr's user interface. new_relational() constructs object class \"relational\". Users encouraged provide class argument. typical use case create wrapper function. rel_to_df() extracts data frame representation relational object, used dplyr::collect(). rel_filter() keeps rows match predicate, used dplyr::filter(). rel_project() selects columns creates new columns, used dplyr::select(), dplyr::rename(), dplyr::mutate(), dplyr::relocate(), others. rel_aggregate() combines several rows one, used dplyr::summarize(). rel_order() reorders rows columns expressions, used dplyr::arrange(). rel_join() joins merges two tables, used dplyr::left_join(), dplyr::right_join(), dplyr::inner_join(), dplyr::full_join(), dplyr::cross_join(), dplyr::semi_join(), dplyr::anti_join(). rel_limit() limits number rows table, used utils::head(). rel_distinct() keeps distinct rows table, used dplyr::distinct(). rel_set_intersect() returns rows present tables, used intersect(). rel_set_diff() returns rows present tables, used setdiff(). rel_set_symdiff() returns rows present tables, used dplyr::symdiff(). rel_union_all() returns rows present tables, used dplyr::union_all(). rel_explain() prints explanation plan executed relational object. rel_alias() returns alias name relational object. rel_set_alias() sets alias name relational object. rel_names() returns column names character vector, used colnames().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational implementer's interface — new_relational","text":"","code":"new_relational(..., class = NULL)  rel_to_df(rel, ...)  rel_filter(rel, exprs, ...)  rel_project(rel, exprs, ...)  rel_aggregate(rel, groups, aggregates, ...)  rel_order(rel, orders, ascending, ...)  rel_join(   left,   right,   conds,   join = c(\"inner\", \"left\", \"right\", \"outer\", \"cross\", \"semi\", \"anti\"),   join_ref_type = c(\"regular\", \"natural\", \"cross\", \"positional\", \"asof\"),   ... )  rel_limit(rel, n, ...)  rel_distinct(rel, ...)  rel_set_intersect(rel_a, rel_b, ...)  rel_set_diff(rel_a, rel_b, ...)  rel_set_symdiff(rel_a, rel_b, ...)  rel_union_all(rel_a, rel_b, ...)  rel_explain(rel, ...)  rel_alias(rel, ...)  rel_set_alias(rel, alias, ...)  rel_names(rel, ...)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational implementer's interface — new_relational","text":"... Reserved future extensions, must empty. class Classes added front \"relational\" base class. rel, rel_a, rel_b, left, right relational object. exprs list \"relational_relexpr\" objects filter , created new_relexpr(). groups list expressions group . aggregates list expressions aggregates compute. orders list expressions order . ascending logical vector describing sort order. conds list expressions use join. join type join. join_ref_type ref type join. n number rows. alias new alias","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational implementer's interface — new_relational","text":"new_relational() returns new relational object. rel_to_df() returns data frame. rel_names() returns character vector. generics return modified relational object.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relational.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational implementer's interface — new_relational","text":"","code":"new_dfrel <- function(x) {   stopifnot(is.data.frame(x))   new_relational(list(x), class = \"dfrel\") } mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])  rel_to_df.dfrel <- function(rel, ...) {   unclass(rel)[[1]] } rel_to_df(mtcars_rel) #>                    mpg cyl disp  hp #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Datsun 710        22.8   4  108  93 #> Hornet 4 Drive    21.4   6  258 110 #> Hornet Sportabout 18.7   8  360 175  rel_filter.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the predicates defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, nrow(df))), ]) }  rel_filter(   mtcars_rel,   list(     relexpr_function(       \"gt\",       list(relexpr_reference(\"cyl\"), relexpr_constant(\"6\"))     )   ) ) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_project.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[seq_len(min(3, ncol(df)))]) }  rel_project(   mtcars_rel,   list(relexpr_reference(\"cyl\"), relexpr_reference(\"disp\")) ) #> [[1]] #>                    mpg cyl disp #> Mazda RX4         21.0   6  160 #> Mazda RX4 Wag     21.0   6  160 #> Datsun 710        22.8   4  108 #> Hornet 4 Drive    21.4   6  258 #> Hornet Sportabout 18.7   8  360 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_order.dfrel <- function(rel, exprs, ...) {   df <- unclass(rel)[[1]]    # A real implementation would evaluate the expressions defined   # by the exprs argument   new_dfrel(df[order(df[[1]]), ]) }  rel_order(   mtcars_rel,   list(relexpr_reference(\"mpg\")) ) #> [[1]] #>                    mpg cyl disp  hp #> Hornet Sportabout 18.7   8  360 175 #> Mazda RX4         21.0   6  160 110 #> Mazda RX4 Wag     21.0   6  160 110 #> Hornet 4 Drive    21.4   6  258 110 #> Datsun 710        22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\" rel_join.dfrel <- function(left, right, conds, join, ...) {   left_df <- unclass(left)[[1]]   right_df <- unclass(right)[[1]]    # A real implementation would evaluate the expressions   # defined by the conds argument,   # use different join types based on the join argument,   # and implement the join itself instead of relaying to left_join().   new_dfrel(dplyr::left_join(left_df, right_df)) }  rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel) #> Joining with `by = join_by(mpg)` #> [[1]] #>   mpg cyl disp  hp #> 1  21   6  160 110 #> 2  21   6  160 110 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_limit.dfrel <- function(rel, n, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[seq_len(n), ]) }  rel_limit(mtcars_rel, 3) #> [[1]] #>                mpg cyl disp  hp #> Mazda RX4     21.0   6  160 110 #> Mazda RX4 Wag 21.0   6  160 110 #> Datsun 710    22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_distinct.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    new_dfrel(df[!duplicated(df), ]) }  rel_distinct(new_dfrel(mtcars[1:3, 1:4])) #> [[1]] #>             mpg cyl disp  hp #> Mazda RX4  21.0   6  160 110 #> Datsun 710 22.8   4  108  93 #>  #> attr(,\"class\") #> [1] \"dfrel\"      \"relational\"  rel_names.dfrel <- function(rel, ...) {   df <- unclass(rel)[[1]]    names(df) }  rel_names(mtcars_rel) #> [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational expressions — new_relexpr","title":"Relational expressions — new_relexpr","text":"functions provide backend-agnostic way construct expression trees built column references, constants, functions. subexpressions expression tree can alias. new_relexpr() constructs object class \"relational_relexpr\". used higher-level constructors, users rarely need call directly. relexpr_reference() constructs reference column. relexpr_constant() wraps constant value. relexpr_function() applies function. arguments function list expression objects. relexpr_window() applies function window, similarly SQL clause. relexpr_set_alias() assigns alias expression.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational expressions — new_relexpr","text":"","code":"new_relexpr(x, class = NULL)  relexpr_reference(name, rel = NULL, alias = NULL)  relexpr_constant(val, alias = NULL)  relexpr_function(name, args, alias = NULL)  relexpr_window(   expr,   partitions,   order_bys = list(),   offset_expr = NULL,   default_expr = NULL,   alias = NULL )  relexpr_set_alias(expr, alias = NULL)"},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational expressions — new_relexpr","text":"x object. class Classes added front \"relational_relexpr\" base class. name name column function reference. rel name relation reference. alias alias new expression. val value use constant expression. args Function arguments, list expr objects. expr expr object. partitions Partitions, list expr objects. order_bys variables order results (list). offset_expr offset relational expression. default_expr default relational expression.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational expressions — new_relexpr","text":"object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\" object class \"relational_relexpr\"","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/new_relexpr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational expressions — new_relexpr","text":"","code":"relexpr_set_alias(   alias = \"my_predicate\",   relexpr_function(     \"<\",     list(       relexpr_reference(\"my_number\"),       relexpr_constant(42)     )   ) ) #> List of 3 #>  $ name : chr \"<\" #>  $ args :List of 2 #>   ..$ :List of 3 #>   .. ..$ name : chr \"my_number\" #>   .. ..$ rel  : NULL #>   .. ..$ alias: NULL #>   .. ..- attr(*, \"class\")= chr [1:2] \"relational_relexpr_reference\" \"relational_relexpr\" #>   ..$ :List of 2 #>   .. ..$ val  : num 42 #>   .. ..$ alias: NULL #>   .. ..- attr(*, \"class\")= chr [1:2] \"relational_relexpr_constant\" \"relational_relexpr\" #>  $ alias: chr \"my_predicate\" #>  - attr(*, \"class\")= chr [1:2] \"relational_relexpr_function\" \"relational_relexpr\""},{"path":"https://duckdblabs.github.io/duckplyr/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. dplyr %>%, across, add_count, add_tally, all_equal, anti_join, arrange, , bind_cols, bind_rows, c_across, case_match, case_when, coalesce, collapse, collect, compute, consecutive_id, count, cross_join, cumall, cumany, cume_dist, cummean, cur_column, cur_group, cur_group_id, cur_group_rows, dense_rank, desc, distinct, explain, filter, first, full_join, if_all, if_any, if_else, inner_join, intersect, join_by, lag, last, lead, left_join, min_rank, mutate, n, n_distinct, na_if, near, nest_by, nest_join, nth, ntile, order_by, percent_rank, pick, pull, reframe, relocate, rename, rename_with, right_join, row_number, rows_append, rows_delete, rows_insert, rows_patch, rows_update, rows_upsert, sample_frac, sample_n, select, semi_join, setdiff, setequal, slice, slice_head, slice_max, slice_min, slice_sample, slice_tail, summarise, summarize, symdiff, tally, tbl_vars, tibble, top_n, transmute, ungroup, union, union_all, with_groups, with_order rlang .data tibble add_row, as_tibble, tribble tidyselect all_of, any_of, contains, everything, last_col, matches, num_range, one_of, starts_with, ","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":null,"dir":"Reference","previous_headings":"","what":"Show stats — stats_show","title":"Show stats — stats_show","text":"Prints statistics many calls handled DuckDB. output shows total number requests current session, split fallbacks dplyr requests handled duckdb.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show stats — stats_show","text":"","code":"stats_show()"},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show stats — stats_show","text":"Called side effect.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/reference/stats_show.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show stats — stats_show","text":"","code":"stats_show() #> 🛠: 10 #> 🔨:  2 #> 🦆:  8 #> inner_join, mutate, mutate.data.frame  tibble(a = 1:3) %>%   as_duckplyr_df() %>%   mutate(b = a + 1) #> materializing: #> --------------------- #> --- Relation Tree --- #> --------------------- #> Projection [a as a, +(a, 1.0) as b] #>   r_dataframe_scan(0x5561e6d33798) #>  #> --------------------- #> -- Result Columns  -- #> --------------------- #> - a (INTEGER) #> - b (DOUBLE) #>  #> # A tibble: 3 × 2 #>       a     b #>   <int> <dbl> #> 1     1     2 #> 2     2     3 #> 3     3     4  stats_show() #> 🛠: 11 #> 🔨:  2 #> 🦆:  9 #> inner_join, mutate, mutate.data.frame"},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-4-0-9003","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.4.0.9003 (2024-07-09)","text":"Update constructive, sync.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-4-0-9003","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.4.0.9003 (2024-07-09)","text":"Tweak README.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-0409002-2024-06-30","dir":"Changelog","previous_headings":"","what":"duckplyr 0.4.0.9002 (2024-06-30)","title":"duckplyr 0.4.0.9002 (2024-06-30)","text":"Internal changes .","code":""},{"path":[]},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-4-0-9001","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.4.0.9001 (2024-06-26)","text":"Support descending sort character non-numeric data (@toppyy, #92, #175).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-0409000-2024-05-21","dir":"Changelog","previous_headings":"","what":"duckplyr 0.4.0.9000 (2024-05-21)","title":"duckplyr 0.4.0.9000 (2024-05-21)","text":"Merge branch ‘cran-0.4.0’.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-040-2024-05-21","dir":"Changelog","previous_headings":"","what":"duckplyr 0.4.0 (2024-05-21)","title":"duckplyr 0.4.0 (2024-05-21)","text":"CRAN release: 2024-05-21","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-4-0","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.4.0 (2024-05-21)","text":"Use built-rfuns extension implement equality inequality operators, improve translation .integer(), NA %% (#83, #154, #148, #155, #159, #160). Reexport non-deprecated dplyr functions (#144, #163). library(duckplyr) calls methods_overwrite() (#164). allow constant patterns grepl(). Explicitly reject calls named arguments now. Reduce default memory limit 1 GB.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.4.0 (2024-05-21)","text":"Stricter type checks set operations intersect(), setdiff(), symdiff(), union(), union_all() (#169). Distinguish constant NA used expression (#157). head(-1) forwards default implementation (#131, #156). Fix cli syntax internal error message (#151). careful detection row names data frame. Always check roundtrip timestamp columns. left_join() join functions call auto_copy(). reset expression depth set . Require fallback result contains duplicate column names ignoring case. row_number() returns integer. .na(NaN) TRUE. summarise(count = n(), count = n()) creates one column named count. Correct wording instructions enabling fallback logging (@TimTaylor, #141).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-4-0","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.4.0 (2024-05-21)","text":"Remove styler dependency (#137, #138). Avoid error stats collection.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-4-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.4.0 (2024-05-21)","text":"Mention wildcards read multiple files ?df_from_file (@andreranza, #133, #134).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"testing-0-4-0","dir":"Changelog","previous_headings":"","what":"Testing","title":"duckplyr 0.4.0 (2024-05-21)","text":"Reenable tests now run successfully (#166). Synchronize tests (#153). Test vec_ptype() materialize (#149). Improve telemetry tests. Promote equality checks expect_identical() capture differences doubles integers.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-032-2024-03-17","dir":"Changelog","previous_headings":"","what":"duckplyr 0.3.2 (2024-03-17)","title":"duckplyr 0.3.2 (2024-03-17)","text":"CRAN release: 2024-03-17","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.2 (2024-03-17)","text":"Run autoupload function checked static analysis (#122).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-3-2","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.3.2 (2024-03-17)","text":"New df_to_parquet() write Parquet, new convenience functions df_from_csv(), duckdb_df_from_csv(), df_from_parquet() duckdb_df_from_parquet() (#87, #89, #96, #128).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-031-2024-03-08","dir":"Changelog","previous_headings":"","what":"duckplyr 0.3.1 (2024-03-08)","title":"duckplyr 0.3.1 (2024-03-08)","text":"CRAN release: 2024-03-10","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.1 (2024-03-08)","text":"Forbid reuse new columns created summarise() (#72, #106). summarise() longer restores subclass. Disambiguate computation log10() log(). Fix division zero positive negative numbers.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-3-1","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.3.1 (2024-03-08)","text":"New fallback_sitrep() related functionality collecting telemetry data (#102, #107, #110, #111, #115). data collected default, message displayed per session every eight hours. Opt opt setting environment variables. Implement group_by() methods collect fallback information (#94, #104, #105). Set memory limit temporary directory duckdb. Implement suppressWarnings() identity function. Prefer cli::cli_abort() stop() rlang::abort() (#114). Translate .data$.env$. Strict checks column class, supporting integer, numeric, logical, Date, POSIXct, difftime now. environment variable DUCKPLYR_METHODS_OVERWRITE set TRUE, loading duckplyr automatically calls methods_overwrite().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"internal-0-3-1","dir":"Changelog","previous_headings":"","what":"Internal","title":"duckplyr 0.3.1 (2024-03-08)","text":"Better duckdb tests. Use standalone purrr dplyr compatibility.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"testing-0-3-1","dir":"Changelog","previous_headings":"","what":"Testing","title":"duckplyr 0.3.1 (2024-03-08)","text":"Add tests correct base log() log10().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-3-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.3.1 (2024-03-08)","text":"methods_overwrite() methods_restore() show message.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-030-2023-12-10","dir":"Changelog","previous_headings":"","what":"duckplyr 0.3.0 (2023-12-10)","title":"duckplyr 0.3.0 (2023-12-10)","text":"CRAN release: 2023-12-11","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.3.0 (2023-12-10)","text":"grepl(x = NA) gives correct results. Fix auto_copy() non-data-frame input. Add output order preservation filters. distinct() now preserves order corner cases (#77, #78). Consistent computation log(0) log(-1) (#75, #76).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"features-0-3-0","dir":"Changelog","previous_headings":"","what":"Features","title":"duckplyr 0.3.0 (2023-12-10)","text":"allow constants mutate() actually representable duckdb (#73). Avoid translating ifelse(), support if_else() (#79).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-3-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.3.0 (2023-12-10)","text":"Separate explain new relational examples (@wibeasley, #84).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"testing-0-3-0","dir":"Changelog","previous_headings":"","what":"Testing","title":"duckplyr 0.3.0 (2023-12-10)","text":"Add test TPC-H queries can processed.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-3-0","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.3.0 (2023-12-10)","text":"Sync dplyr 1.1.4 (#82). Remove dplyr_reconstruct() method (#48). Render README. Fix code generated meta_replay(). Bump constructive dependency. Fix output order arrange() case ties. Update duckdb tests. implement newer slice_sample(), sample_n() sample_frac() (#74). Sync generated files (#71).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-023-2023-11-08","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.3 (2023-11-08)","title":"duckplyr 0.2.3 (2023-11-08)","text":"CRAN release: 2023-11-08","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"performance-0-2-3","dir":"Changelog","previous_headings":"","what":"Performance","title":"duckplyr 0.2.3 (2023-11-08)","text":"Join using DISTINCT faster execution (duckdb/duckdb-r#41, #68).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-2-3","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.2.3 (2023-11-08)","text":"Add stability README output (@maelle, #62, #65).","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-022-2023-10-16","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.2 (2023-10-16)","title":"duckplyr 0.2.2 (2023-10-16)","text":"CRAN release: 2023-10-16","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-2-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.2.2 (2023-10-16)","text":"summarise() keeps \"duckplyr_df\" class (#63, #64). Fix compatibility duckdb >= 0.9.1.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-2-2","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.2.2 (2023-10-16)","text":"Skip tests give different output dev tidyselect. Import utils::globalVariables().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-2-2","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.2.2 (2023-10-16)","text":"Small README improvements (@maelle, #34, #57). Fix 301 README.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-021-2023-09-16","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.1 (2023-09-16)","title":"duckplyr 0.2.1 (2023-09-16)","text":"CRAN release: 2023-09-17 Improve documentation. Work around problem dplyr_reconstruct() R 4.3. Rename duckdb_from_file() df_from_file(). Unexport private duckdb_rel_from_df(), rel_from_df(), wrap_df() wrap_integer(). Reexport %>% tibble().","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-020-2023-09-10","dir":"Changelog","previous_headings":"","what":"duckplyr 0.2.0 (2023-09-10)","title":"duckplyr 0.2.0 (2023-09-10)","text":"CRAN release: 2023-09-10 Implement relational API DuckDB.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"duckplyr-010-2023-07-03","dir":"Changelog","previous_headings":"","what":"duckplyr 0.1.0 (2023-07-03)","title":"duckplyr 0.1.0 (2023-07-03)","text":"CRAN release: 2023-07-07","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"bug-fixes-0-1-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"duckplyr 0.1.0 (2023-07-03)","text":"Fix examples.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"chore-0-1-0","dir":"Changelog","previous_headings":"","what":"Chore","title":"duckplyr 0.1.0 (2023-07-03)","text":"Add CRAN install instructions. Satisfy R CMD check. Document argument. Error NOTE. Remove relexpr_window() now.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"documentation-0-1-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"duckplyr 0.1.0 (2023-07-03)","text":"Clean reference.","code":""},{"path":"https://duckdblabs.github.io/duckplyr/news/index.html","id":"uncategorized-0-1-0","dir":"Changelog","previous_headings":"","what":"Uncategorized","title":"duckplyr 0.1.0 (2023-07-03)","text":"Initial version, exporting: - new_relational() construct objects class \"relational\" - Generics rel_aggregate(), rel_distinct(), rel_filter(), rel_join(), rel_limit(), rel_names(), rel_order(), rel_project(), rel_set_diff(), rel_set_intersect(), rel_set_symdiff(), rel_to_df(), rel_union_all() - new_relexpr() construct objects class \"relational_relexpr\" - Expression builders relexpr_constant(), relexpr_function(), relexpr_reference(), relexpr_set_alias(), relexpr_window()","code":""}]
