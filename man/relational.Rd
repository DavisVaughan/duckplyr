% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/relational-rel.R
\name{relational}
\alias{relational}
\alias{new_relational}
\alias{rel_to_df}
\title{Relational implementer's interface}
\usage{
new_relational(..., class = NULL)

rel_to_df(rel, ...)
}
\arguments{
\item{...}{Reserved for future extensions, must be empty.}

\item{class}{Classes added in front of the `"relational"` base class.}

\item{rel}{The relational object.}
}
\value{
A (new/modified) relational object.

A data frame.
}
\description{
The constructor and generics described here define a class
that helps separating dplyr's user interface from the actual underlying operations.
In the longer term, this will help packages that implement the dplyr interface
(such as \pkg{dbplyr}, \pkg{dtplyr}, \pkg{arrow} and similar)
to focus on the core details of their functionality,
rather than on the intricacies of dplyr's user interface.

`new_relational()` constructs an object of class `"relational"`.
Users are encouraged to provide the `class` argument.
The typical use case will be to create a wrapper function.

`rel_to_df()` extracts a data frame representation from a relational object,
to be used by `dplyr::collect()`.
}
\examples{
new_dfrel <- function(x) {
  stopifnot(is.data.frame(x))
  new_relational(list(x), class = "dfrel")
}
mtcars_rel <- new_dfrel(mtcars)

rel_to_df.dfrel <- function(rel, ...) {
  unclass(rel)[[1]]
}
rel_to_df(mtcars_rel)
}
