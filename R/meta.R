pre_code_cache <- collections::queue()
code_cache <- collections::queue()
macro_cache <- collections::dict()
df_cache <- collections::dict()
rel_cache <- collections::dict()

meta_clear <- function() {
  pre_code_cache$clear()
  code_cache$clear()
  macro_cache$clear()
  df_cache$clear()
  rel_cache$clear()
}

meta_pre_record <- function(code) {
  pre_code_cache$push(code)
  invisible()
}

meta_record <- function(code) {
  code_cache$push(code)
  invisible()
}

meta_replay <- function(pre_code = TRUE) {
  con_exprs <- list(
    expr(con <- DBI::dbConnect(duckdb::duckdb())),
    expr(experimental <- !!(Sys.getenv("DUCKPLYR_EXPERIMENTAL") == "TRUE"))
  )
  con_code <- map(con_exprs, constructive::deparse_call)

  # HACK
  count <- rel_cache$size()
  res_name <- sym(paste0("rel", count))
  res_mat_expr <- expr(duckdb:::rel_to_altrep(!!res_name))
  res_code <- map(list(res_name, res_mat_expr), constructive::deparse_call)

  all_code <- c(
    if (pre_code) c(con_code, pre_code_cache$as_list()),
    code_cache$as_list(),
    res_code
  )

  walk(all_code, print)
}

meta_replay_to_fun_file <- function(name) {
  code <- capture.output(meta_replay(pre_code = FALSE))
  code <- c(
    "# Generated by meta_replay_to_fun_file(), do not edit by hand",
    paste0(name, " <- function(experimental) {"),
    paste0("  ", code),
    "}"
  )

  path <- file.path("R", paste0(name, ".R"))

  writeLines(code, path)
}

meta_replay_to_file <- function(path, extra = character()) {
  code <- capture.output(meta_replay())
  writeLines(c(extra, code), path)
}

meta_replay_to_new_doc <- function() {
  code <- capture.output(meta_replay())
  rstudioapi::documentNew(code, execute = TRUE)
}

meta_replay_to_reprex <- function(...) {
  code <- capture.output(meta_replay())
  reprex::reprex(input = code, ...)
}

meta_eval <- function() {
  code <- capture.output(meta_replay())
  eval(parse(text = code))
}

meta_macro_register <- function(name) {
  macro <- duckplyr_macros[name]
  if (is.na(macro)) {
    return(invisible())
  }

  if (macro_cache$has(name)) {
    return(invisible())
  }

  macro_expr <- expr(invisible(
    DBI::dbExecute(con, !!paste0('CREATE MACRO "', names(macro), '"', macro))
  ))
  meta_pre_record(constructive::deparse_call(macro_expr))

  macro_cache$set(name, TRUE)
  invisible()
}

meta_df_register <- function(df) {
  if (df_cache$has(df)) {
    return(invisible(df_cache$get(df)))
  }

  count <- df_cache$size()
  name <- sym(paste0("df", count + 1))

  df_expr <- NULL

  if (Sys.getenv("DUCKPLYR_META_GLOBAL") == "TRUE") {
    global_dfs <- mget(ls(.GlobalEnv), .GlobalEnv, mode = "list", ifnotfound = list(NULL))

    for (df_name in names(global_dfs)) {
      global_df <- global_dfs[[df_name]]
      if (identical(df, global_df)) {
        df_expr <- sym(df_name)
        break
      }
    }
  }

  df_cache$set(df, name)

  if (is.null(df_expr)) {
    meta_record(constructive::construct_multi(list2(!!name := df)))
  } else {
    # Changes df in-place!
    class(df) <- setdiff(class(df), "duckplyr_df")
    meta_record(constructive::deparse_call(expr(!!name <- !!df_expr)))
  }

  invisible(name)
}

meta_rel_register_df <- function(rel, df) {
  df_name <- meta_df_register(df)
  # Expect experimental argument from outside
  rel_expr <- expr(duckdb:::rel_from_df(con, !!df_name, experimental = experimental))
  meta_rel_register(rel, rel_expr)
}

meta_rel_register <- function(rel, rel_expr) {
  force(rel_expr)

  count <- rel_cache$size()
  name <- sym(paste0("rel", count + 1))

  # https://github.com/cynkra/constructive/issues/102

  expr <- constructive::deparse_call(expr(!!name <- !!rel_expr))
  meta_record(expr)

  obj <- list(rel = rel, name = name, df = df)
  hash <- deparse(rel)

  rel_cache$set(hash, obj)
  invisible()
}

meta_rel_get <- function(rel) {
  hash <- deparse(rel)

  if (!rel_cache$has(hash)) {
    abort(
      c(
        "duckplyr: internal: hash not found",
        i = paste0("hash: ", hash),
        i = paste0("relation: ", paste(capture.output(print(rel), type = "message"), collapse = "\n"))
      )
    )
  }

  rel_cache$get(hash)
}
