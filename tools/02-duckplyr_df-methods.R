source("tools/00-funs.R", echo = TRUE)

func_decl <- function(formals, is_tbl_return) {
  data_arg <- sym(names(formals)[[1]])
  if (is_tbl_return) {
    rlang::new_function(formals, expr({
      force(!!data_arg)
      # FIXME: how to run all dplyr tests?
      # - Tweak tests so that they call helpers that convert args to duckdf-s first?
      # - Tweak tests so that they run with duckdf-s instead of tibbles
      #   or data frames?
      # - Avoid NextMethod(), forward directly to dplyr implementation?
      # - ...?
      out <- NextMethod()
      out <- dplyr_reconstruct(out, !!data_arg)
      return(out)
    }))
  } else {
    rlang::new_function(formals, expr({
      force(!!data_arg)
      out <- NextMethod()
      return(out)
    }))
  }
}

first_line <- "# Generated by 02-duckplyr_df-methods.R"

func_decl_chr <- function(generic, code, name, new_code_chr, is_tbl_return) {
  formals <- formals(code)

  two_tables <- (length(formals) > 1) && (names(formals)[[2]] == "y")

  new_code_chr <- paste(capture.output(print(new_code_chr)), collapse = "\n")
  new_code_chr <- gsub("[{]", "{\n  # Our implementation", new_code_chr)

  dplyr_code <- brio::read_file(fs::path("dplyr-methods", paste0(generic, ".txt")))
  dplyr_impl <- c(
    "",
    "  # dplyr implementation",
    gsub("^[^{]*[{]\n", "", dplyr_code, perl = TRUE)
  )

  new_code_chr <- gsub("[}]", paste(dplyr_impl, collapse = "\n"), new_code_chr)

  if (two_tables) {
    arg_1 <- names(formals)[[1]]
    arg_2 <- names(formals)[[2]]
    args <- paste0(arg_1, ", ", arg_2)
    assign_impl <- c(
      '    {',
      '      {{{arg_1}}} <- as_duckplyr_df({{{arg_1}}})',
      '      {{{arg_2}}} <- as_duckplyr_df({{{arg_2}}})',
      '    },'
    )
  } else {
    arg_1 <- names(formals)[[1]]
    args <- arg_1
    assign_impl <- c(
      '    {{{arg_1}}} <- as_duckplyr_df({{{arg_1}}}),'
    )
  }

  if (generic %in% c("group_by", "rowwise")) {
    test_impl <- c(
      '  testthat::skip("`{{{generic}}}()` not supported for duckplyr")'
    )
  } else {
    test_impl <- c(
      '  try_fetch(',
      assign_impl,
      '    error = function(e) {',
      '      testthat::skip(conditionMessage(e))',
      '    }',
      '  )',
      '  out <- {{{generic}}}({{{args}}}, ...)',
      if (is_tbl_return) '  class(out) <- setdiff(class(out), "duckplyr_df")',
      '  out'
    )
  }

  test_code <- c(
    'duckplyr_{{{generic}}} <- function({{args}}, ...) {',
    test_impl,
    '}',
    ''
  )

  test_code <- whisker::whisker.render(test_code)

  code <- paste0(
    first_line,
    "\n",
    "#' @importFrom dplyr ",
    generic,
    "\n#' @export\n",
    name,
    " <- ",
    new_code_chr,
    "\n",
    test_code
  )
  code
}

duckplyr_df_methods <-
  df_methods %>%
  filter(!skip_impl) %>%
  mutate(formals = map(code, formals)) %>%
  mutate(new_code = map2(formals, is_tbl_return, func_decl)) %>%
  mutate(new_code_chr = map(new_code, constructive::construct, check = FALSE)) %>%
  mutate(new_fun = paste0(name, ".duckplyr_df")) %>%
  rowwise() %>%
  mutate(decl_chr = func_decl_chr(name, code, new_fun, new_code_chr, is_tbl_return)) %>%
  ungroup()

old <-
  tibble(path = fs::dir_ls("R")) %>%
  mutate(first_line = map_chr(path, brio::read_lines, 1)) %>%
  filter(first_line == !!first_line)

fs::file_delete(old$path)

duckplyr_df_methods %>%
  mutate(path = fs::path("R", paste0(name, ".R"))) %>%
  select(text = decl_chr, path) %>%
  pwalk(brio::write_file)

# Patch files -------------------------------------------------------------------------

patches <- fs::dir_ls("patch")

walk(patches, ~ system(paste0("patch -p1 < ", .x)))

# Collect new patches -----------------------------------------------------------------

r_status <- gert::git_status(pathspec = "R")

if (nrow(r_status) == 1) {
  patch_path <- gsub("R/(.*)[.]R", "patch/\\1.patch", r_status$file)
  if (fs::file_exists(patch_path)) {
    system(paste0("patch -p1 -R < ", patch_path))
  }
  system(paste0("git diff -R -- ", r_status$file, " > ", patch_path))
  system(paste0("git checkout -- ", r_status$file))
} else if (nrow(r_status) > 0) {
  stop("Too many files change, inspect manually.")
}
