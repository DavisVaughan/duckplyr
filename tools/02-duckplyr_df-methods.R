# pak::pak("cynkra/constructive")
library(tidyverse)

dplyr <- asNamespace("dplyr")

s3_methods <- as_tibble(
  matrix(as.character(dplyr$.__NAMESPACE__.$S3methods), ncol = 4),
  .name_repair = ~ c("name", "class", "fun", "what")
)

df_methods <-
  s3_methods %>%
  filter(class == "data.frame") %>%
  # deprecated and lazyeval methods, won't implement
  filter(!grepl("_$|^as[.]tbl$", name)) %>%
  # special dplyr methods, won't implement
  filter(!(name %in% c("dplyr_col_modify", "dplyr_row_slice"))) %>%
  mutate(code = unname(mget(fun, dplyr)))

func_decl <- function(formals) {
  data_arg <- sym(names(formals)[[1]])
  rlang::new_function(formals, expr({
    force(!!data_arg)
    out <- NextMethod()
    out <- dplyr_reconstruct(out, !!data_arg)
    return(out)
  }))
}

first_line <- "# Generated by 02-duckplyr_df-methods.R"

func_decl_chr <- function(generic, name, code) {
  code <- paste(capture.output(print(code)), collapse = "\n")
  code <- paste0(
    first_line,
    "\n",
    "#' @importFrom dplyr ",
    generic,
    "\n#' @export\n",
    name,
    " <- ",
    code,
    "\n"
  )
  code <- gsub("[{]", "{\n  #", code)
  code
}

duckplyr_df_methods <-
  df_methods %>%
  mutate(formals = map(code, formals)) %>%
  mutate(new_code = map(formals, func_decl)) %>%
  mutate(new_code_chr = map(new_code, constructive::construct, check = FALSE)) %>%
  mutate(new_fun = paste0(name, ".duckplyr_df")) %>%
  rowwise() %>%
  mutate(decl_chr = func_decl_chr(name, new_fun, new_code_chr)) %>%
  ungroup()

old <-
  tibble(path = fs::dir_ls("R")) %>%
  mutate(first_line = map_chr(path, brio::read_lines, 1)) %>%
  filter(first_line == !!first_line)

fs::file_delete(old$path)

duckplyr_df_methods %>%
  mutate(path = fs::path("R", paste0(name, ".R"))) %>%
  select(text = decl_chr, path) %>%
  pwalk(brio::write_file)
