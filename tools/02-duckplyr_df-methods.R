source("tools/00-funs.R", echo = TRUE)

func_decl <- function(formals, is_tbl_return) {
  data_arg <- sym(names(formals)[[1]])
  if (is_tbl_return) {
    rlang::new_function(formals, expr({
      force(!!data_arg)
      # FIXME: how to run all dplyr tests?
      # - Tweak tests so that they call helpers that convert args to duckdf-s first?
      # - Tweak tests so that they run with duckdf-s instead of tibbles
      #   or data frames?
      # - Avoid NextMethod(), forward directly to dplyr implementation?
      # - ...?
      out <- NextMethod()
      out <- dplyr_reconstruct(out, !!data_arg)
      return(out)
    }))
  } else {
    rlang::new_function(formals, expr({
      force(!!data_arg)
      out <- NextMethod()
      return(out)
    }))
  }
}

first_line <- "# Generated by 02-duckplyr_df-methods.R"

func_decl_chr <- function(generic, code, name, new_code_chr, is_tbl_return) {
  formals <- formals(code)

  two_tables <- (length(formals) > 1) && (names(formals)[[2]] == "y")

  new_code_chr <- paste(capture.output(print(new_code_chr)), collapse = "\n")
  new_code_chr <- gsub("[{]", "{\n  # Our implementation", new_code_chr)

  dplyr_code <- brio::read_file(fs::path("dplyr-methods", paste0(generic, ".R")))
  dplyr_impl <- c(
    "",
    "  # dplyr implementation",
    gsub("^[^{]*[{]\n", "", dplyr_code, perl = TRUE)
  )

  new_code_chr <- gsub("[}]", paste(dplyr_impl, collapse = "\n"), new_code_chr)

  if (generic %in% c("group_by", "rowwise")) {
    test_impl <- c(
      '  testthat::skip("`{{{generic}}}()` not supported for duckplyr")'
    )
  } else {
    test_impl <- c(
      '  if (is_grouped_df(.data)) {',
      '    testthat::skip("`{{{generic}}}()` not supported for grouped_df")',
      '  }',
      '',
      '  if (inherits(.data, "rowwise_df")) {',
      '    testthat::skip("`{{{generic}}}()` not supported for rowwise_df")',
      '  }',
      '',
      '  .data <- as_duckplyr_df(.data)',
      '  out <- {{{generic}}}(.data, ...)',
      if (is_tbl_return) '  class(out) <- setdiff(class(out), "duckplyr_df")',
      '  out'
    )
  }

  test_code <- c(
    'duckplyr_{{{generic}}} <- function(.data, ...) {',
    test_impl,
    '}',
    ''
  )

  test_code <- whisker::whisker.render(test_code)

  code <- paste0(
    first_line,
    "\n",
    "#' @importFrom dplyr ",
    generic,
    "\n#' @export\n",
    name,
    " <- ",
    new_code_chr,
    "\n",
    test_code
  )
  code
}

duckplyr_df_methods <-
  df_methods %>%
  filter(!skip_impl) %>%
  mutate(formals = map(code, formals)) %>%
  mutate(new_code = map2(formals, is_tbl_return, func_decl)) %>%
  mutate(new_code_chr = map(new_code, constructive::construct, check = FALSE)) %>%
  mutate(new_fun = paste0(name, ".duckplyr_df")) %>%
  rowwise() %>%
  mutate(decl_chr = func_decl_chr(name, code, new_fun, new_code_chr, is_tbl_return)) %>%
  ungroup()

old <-
  tibble(path = fs::dir_ls("R")) %>%
  mutate(first_line = map_chr(path, brio::read_lines, 1)) %>%
  filter(first_line == !!first_line)

fs::file_delete(old$path)

duckplyr_df_methods %>%
  mutate(path = fs::path("R", paste0(name, ".R"))) %>%
  select(text = decl_chr, path) %>%
  pwalk(brio::write_file)
