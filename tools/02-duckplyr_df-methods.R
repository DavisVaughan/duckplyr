# pak::pak("cynkra/constructive")
library(tidyverse)

dplyr <- asNamespace("dplyr")

s3_methods <- as_tibble(
  matrix(as.character(dplyr$.__NAMESPACE__.$S3methods), ncol = 4),
  .name_repair = ~ c("name", "class", "fun", "what")
)

df_methods <-
  s3_methods %>%
  filter(class == "data.frame") %>%
  # deprecated and lazyeval methods, won't implement
  filter(!grepl("_$|^as[.]tbl$", name)) %>%
  # special dplyr methods, won't implement
  filter(!(name %in% c("dplyr_col_modify", "dplyr_row_slice"))) %>%
  # methods we don't need to implement but can test
  filter(!(name %in% c("collapse", "collect", "compute"))) %>%
  mutate(is_tbl_return = !(name %in% c(
    # Special case: forward to `NextMethod()`, don't change implementation
    "dplyr_reconstruct",
    "auto_copy", "group_indices", "group_size", "group_vars", "groups",
    "n_groups", "pull", "same_src", "setequal", "tbl_vars"
  ))) %>%
  mutate(code = unname(mget(fun, dplyr)))

func_decl <- function(formals, is_tbl_return) {
  data_arg <- sym(names(formals)[[1]])
  if (is_tbl_return) {
    rlang::new_function(formals, expr({
      force(!!data_arg)
      out <- NextMethod()
      out <- dplyr_reconstruct(out, !!data_arg)
      return(out)
    }))
  } else {
    rlang::new_function(formals, expr({
      force(!!data_arg)
      out <- NextMethod()
      return(out)
    }))
  }
}

first_line <- "# Generated by 02-duckplyr_df-methods.R"

func_decl_chr <- function(generic, name, code) {
  code <- paste(capture.output(print(code)), collapse = "\n")
  code <- gsub("[{]", "{\n  # Our implementation", code)

  dplyr_code <- brio::read_file(fs::path("dplyr-methods", paste0(generic, ".R")))
  dplyr_impl <- c(
    "",
    "  # dplyr implementation",
    gsub("^[^{]*[{]\n", "", dplyr_code, perl = TRUE)
  )

  code <- gsub("[}]", paste(dplyr_impl, collapse = "\n"), code)

  code <- paste0(
    first_line,
    "\n",
    "#' @importFrom dplyr ",
    generic,
    "\n#' @export\n",
    name,
    " <- ",
    code
  )
  code
}

duckplyr_df_methods <-
  df_methods %>%
  mutate(formals = map(code, formals)) %>%
  mutate(new_code = map2(formals, is_tbl_return, func_decl)) %>%
  mutate(new_code_chr = map(new_code, constructive::construct, check = FALSE)) %>%
  mutate(new_fun = paste0(name, ".duckplyr_df")) %>%
  rowwise() %>%
  mutate(decl_chr = func_decl_chr(name, new_fun, new_code_chr)) %>%
  ungroup()

old <-
  tibble(path = fs::dir_ls("R")) %>%
  mutate(first_line = map_chr(path, brio::read_lines, 1)) %>%
  filter(first_line == !!first_line)

fs::file_delete(old$path)

duckplyr_df_methods %>%
  mutate(path = fs::path("R", paste0(name, ".R"))) %>%
  select(text = decl_chr, path) %>%
  pwalk(brio::write_file)
