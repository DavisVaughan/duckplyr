source("tools/00-funs.R", echo = TRUE)

first_line <- '# Generated by 03-tests.R\n\nwithr::local_envvar(DUCKPLYR_FORCE = "TRUE")'

extra_arg_map <- list(
  do = "data.frame(c = 1)",
  dplyr_reconstruct = "test_df",
  filter = "a == 1",
  group_map = "~ .x",
  group_modify = "~ .x",
  rename = "c = a",
  rename_with = "identity",
  rows_insert = ', conflict = "ignore"',
  sample_n = "size = 1",
  select = "a",
  slice_max = 'a',
  slice_min = 'a',
  summarise = "c = mean(a)",
  transmute = "c = a + 1",
  NULL
)

skip_map <- c(
  # FIXME: Fail with group_by()
  dplyr_reconstruct = "Hack",
  group_by = "Grouped",
  group_map = "WAT",
  group_modify = "Grouped",
  group_nest = "Always returns tibble",
  group_split = "WAT",
  group_trim = "Grouped",
  nest_by = "WAT",
  # FIXME: Fail with rowwise()
  rowwise = "Stack overflow",
  slice_head = "External vector?",
  slice_max = "External vector?",
  slice_min = "External vector?",
  slice_sample = "External vector?",
  slice_tail = "External vector?",
  ungroup = "Grouped",
  NULL
)

force_override <- c(
  nest_join = FALSE,
  NULL
)

get_test_code <- function(name, code, is_tbl_return) {
  formals <- formals(code)
  two_tables <- (length(formals) > 1) && (names(formals)[[2]] == "y")

  if (is_tbl_return) {
    post_coerce <- " %>% as_duckplyr_df()"
  } else {
    post_coerce <- ""
  }

  extra_arg <- extra_arg_map[[name]] %||% ""

  with_force <- force_override[name] %|% fs::file_exists(fs::path("patch", paste0(name, ".patch")))
  if (with_force) {
    force <- ""
  } else {
    force <- '  withr::local_envvar(DUCKPLYR_FORCE = "FALSE")\n'
  }

  skip <- skip_map[name]
  if (is.na(skip)) {
    skip <- ""
  } else {
    skip <- paste0('  skip("', skip, '")\n\n')
  }

  extra_arg_esc <- gsub('"', '\\\\"', extra_arg)

  test_code_pre <- c(
    'test_that("as_duckplyr_df() commutes for {{{name}}}({{{extra_arg_esc}}})", {',
    "{{{force}}}{{{skip}}}  # Data"
  )

  if (two_tables) {
    test_code <- c(
      "  test_df_x <- data.frame(a = 1, b = 2)",
      "  test_df_y <- data.frame(a = 1, b = 2)",
      "",
      "  # Run",
      "  pre <- test_df_x %>% as_duckplyr_df() %>% {{{name}}}(test_df_y{{{extra_arg}}})",
      "  post <- test_df_x %>% {{{name}}}(test_df_y{{{extra_arg}}}){{{post_coerce}}}"
    )
  } else {
    test_code <- c(
      "  test_df <- data.frame(a = 1, b = 2)",
      "",
      "  # Run",
      "  pre <- test_df %>% as_duckplyr_df() %>% {{{name}}}({{{extra_arg}}})",
      "  post <- test_df %>% {{{name}}}({{{extra_arg}}}){{{post_coerce}}}"
    )
  }

  test_code_post <- c(
    "",
    "  # Compare",
    "  expect_equal(pre, post)",
    "})",
    ""
  )

  test_code <- whisker::whisker.render(c(test_code_pre, test_code, test_code_post))
}

old <-
  tibble(path = fs::dir_ls("tests/testthat", glob = "*.R")) %>%
  mutate(first_line = map_chr(path, brio::read_lines, 1)) %>%
  filter(first_line == !!first_line)

fs::file_delete(old$path)

tests <-
  df_methods %>%
  mutate(test_code = pmap_chr(list(name, code, is_tbl_return), get_test_code))

all_tests <-
  paste0(
    first_line, "\n\n",
    paste(tests$test_code, collapse = "\n")
  )

brio::write_file(all_tests, "tests/testthat/test-as_duckplyr_df.R")
